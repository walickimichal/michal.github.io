\documentstyle{esub2acm}
%\documentclass[10pt]{article} 

% Article: ``Algebraic Approaches to Nondeterminism''
% by M.Walicki and S.Meldal

%% this file, walicki.tex, contains:
%% 1. a list of local macro definitions
%% 2. header and stuff
%% 3. the main text
%% 4. {thebibliography}, i.e., the .bbl file inserted
%%
%%    and !!!!
%%
%% 5 - diagrams are drawn using the Xy-pic package available from
%%     http://www.brics.dk/~krisrose/Xy-pic.html
%% If you want to insert diagrams in another way you should:
%%   a) remove '\input xypic' command before the \title
%%   b) remove the macros marked as 'auxiliaries for XY-pic diagrams'
%%      and their applications in the text
%%   c) remove everything which in the text stands 
%%      between '\diagram'...'\enddiagram'
%%   d) insert your diagrams the way you want


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% local macros

\newcommand{\RLSX}{{\cal T}_{S}(X)}
\newcommand{\RLS}{{\cal T}_{S}}
\newcommand{\SCAT}{{\sf RL}_S}
\newcommand{\SPO}{{\sf PO}_S}
\newcommand{\CPOS}{{\sf CPO}_S}
\newcommand{\src}{\partial_s}
\newcommand{\trg}{\partial_t}
\newcommand{\refl}{\mathrel{\hookrightarrow}}
\newcommand{\Terms}{W}
\newcommand{\GTerms}{W_{\Sigma}}
\newcommand{\XTerms}[1]{W_{{\Sigma,#1}}}
\newcommand{\ch}{\sqcup}
\newcommand{\meet}{\mathrel{\sqcap}}
\newcommand{\Car}[1]{|#1|}
\newcommand{\PSet}{{\cal P}}
\newcommand{\Plot}{{\sf P}}
\renewcommand{\iff}{\mathrel{\Leftrightarrow}}
\newcommand{\impl}{\mathrel{\Rightarrow}}
\newcommand{\into}{\mathrel{\rightarrow}}
\newcommand{\addinto}{\mathrel{\rightarrow_{\cup}}}
\newcommand{\strinto}{\mathrel{\rightarrow_{+}}}
\newcommand{\singinto}{\mathrel{\rightarrow_{1}}}
\newcommand{\addstrinto}{\mathrel{\rightarrow_{\uplus}}}
\newcommand{\es}{\emptyset}
\newcommand{\Incl}{\mathrel{\prec}}
\newcommand{\seteq}{\mathrel{\asymp}}
\newcommand{\nothing}{{\sf nothing}}
\newcommand{\Sorts}{{\cal S}}
\newcommand{\Funcs}{{\cal F}}
\newcommand{\Vars}{{\cal V}}
\newcommand{\Lang}{{\cal L}}
\newcommand{\bool}{{\rm{Bool}}}
\newcommand{\Nat}{{\rm{Nat}}}
\newcommand{\true}{{\sf true}}
\newcommand{\false}{{\sf false}}
\newcommand{\rew}{\mathrel{\mapsto}}
\newcommand{\rewc}{\mathrel{\stackrel{*}\rew}}
\newcommand{\reww}[1]{\mathrel{\stackrel{{\scriptscriptstyle{#1}}}\rew}}
\newcommand{\intow}[1]{\mathrel{\stackrel{{\scriptscriptstyle{#1}}}\into}}
\newcommand{\iso}{\mathrel{\simeq}}
\newcommand{\uni}{{\cal I}}
\newcommand{\und}[1]{\underline{#1}}
\newcommand{\res}[1]{\{#1\}}
\newcommand{\prule}[2]{{\displaystyle #1 \over \displaystyle#2}}

\newcommand{\tree}[1]{\hat #1}
\newcommand{\cpo}{\mathrel{\sqsubseteq}}
\newcommand{\pred}[1]{P_{#1}}
\newcommand{\pr}{\vdash}
\newcommand{\syeq}{\mathrel{\equiv}}
\def\theequation{\arabic{section}.\arabic{equation}}
\newcommand{\refp}[1]{(\ref{#1})}
\newcommand{\FMod}{F\!M\!od}
\newcommand{\MMod}{M\!M\!od}
\newcommand{\PMod}{P\!M\!od}
\newcommand{\MHom}{M\!H\!om}
\newcommand{\EHom}{E\!H\!om}
\newcommand{\PHom}{P\!H\!om}

%%%%%%%%%%%% Envs
\newcommand{\eq}[1]{\begin{equation} #1 \end{equation}}
\newcommand{\para}[1]{\subsubsection*{{\bf #1}}}
%\paragraph*{#1}\par\noindent 

\newcommand{\MyLPar}{\parsep -.2ex plus.2ex minus.2ex\itemsep\parsep 
\vspace{-\topsep}\vspace{.5ex}}
\newenvironment{enum}{\begin{enumerate}\MyLPar}{\end{enumerate}}

\newcounter{CLAIM}[section]
\def\theCLAIM{\arabic{section}.\arabic{CLAIM}}

\newtheorem{Claim}[CLAIM]{Proposition}  
\newtheorem{Definition}[CLAIM]{Definition} 
\newtheorem{Fact}[CLAIM]{Fact}     
\newtheorem{Lemma}[CLAIM]{Lemma}     
\newtheorem{Example}[CLAIM]{Example} 
\newtheorem{Theorem}[CLAIM]{Theorem} 
\newtheorem{Corollary}[CLAIM]{Corollary}  
\newenvironment{Proof}
               {\setlength{\parskip}{2pt}
                \setlength{\parindent}{0pt}
                {\sc Proof:}}{\hfill{\sc qed}\vspace{1.5ex}}

%%%% auxiliaries for XY-pic diagrams

\newcommand{\scol}[1]{\spreaddiagramcolumns{#1}}
\newcommand{\srow}[1]{\spreaddiagramrows{#1}}
\newcommand{\maly}[2]{
  \scol{-#1pc}\srow{-#2pc}\def\objectstyle{\scriptstyle}\def\labelstyle{\scriptstyle}}
\newcommand{\sdrop}[1]{\save\drop{#1}\restore}

%%%%%%%%%%%%%%% end of local macros
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input xypic       
\xyoption{curve}

\title{Algebraic Approaches to Nondeterminism\\ -- an Overview}
\author{Micha{\l} Walicki and Sigurd Meldal\\
 University of Bergen, Dept. of Informatics, 
         5020 Bergen, Norway
         {\small{(michal,sigurd@ii.uib.no)}} }
\category{A.1}{General Literature}{Introductory and Survey}
\category{F.3.1}{Theory of Computation}{Logics and Meanings of Programs}[Specification techniques]
\category{F.3.2}{}{}[Algebraic approaches to semantics]
\category{F.4.1}{}{Mathematical Logic}[Computational logic]
\terms{design, languages, theory}
\keywords{nondeterminism, algebraic specification}

\begin{document}

\begin{bottomstuff}
This research was funded 
by the Royal Norwegian Research Council under grant 100426/410 and by the 
U.S. Air Force Office of Scientific Research under grant AFOSR-91-0354. 
S.~Meldal was also funded by ARPA under ONR contract N00014-93-1-1335. 
A preliminary version of this paper was published as Walicki, M.A. and 
Meldal, S., 1995, Nondeterministic Operators in Algebraic Frameworks, 
Tehnical Report No. CSL--TR--95--664, Stanford University.
\end{bottomstuff}

\markboth{M. Walicki and S. Meldal}
	 {Algebraic Approaches to Nondeterminism}


\maketitle
\vspace*{-6ex}
{\footnotesize{\tableofcontents}}  
\vspace{4ex}

\noindent Mathematics never saw much of a reason to deal with something 
called ``nondeterminism''.  It works with values, functions, sets, 
relations.  In computing science, on the other hand, nondeterminism has 
been an issue from the very beginning, if only in the form of 
nondeterministic Turing machines or nondeterministic finite state machines.  
Early references to nondeterminism in computer science go back to the 
sixties \cite{c:38,c:84}.  A great variety of theories and formalisms 
dealing with it have been developed during the last two decades.  There are 
the denotational models based on power domains \cite{c:103, c:117, c:51, 
c:106}, the predicate transformers for the choice construct \cite{c:29, 
c:30, c:Hes, c:Nel, c:104, c:118}, and modifications of the $\lambda$-calculus 
\cite{c:73, c:4, c:49}.  Nondeterminism arises in a natural way when 
discussing concurrency, and models of concurrency typically also model 
nondeterminism.  There are numerous variants of process languages and 
algebras \cite{c:13, c:89, c:90, c:101a, c:50, c:54, c:52, c:65, c:39, c:11}, event 
structures \cite{c:2, c:136, c:135, c:134}, state transition systems 
\cite{c:83, c:71}, Petri nets \cite{c:100, c:109}.

 In terms of modeling,
nondeterminism may be considered a purely operational notion. 
However, one of the main reasons for considering nondeterminism 
in computer science is the need for abstraction, allowing one to 
disregard irrelevant aspects of actual computations. Typically, we 
prefer to work with models which do not include all the details 
of the physical environment of computations such as timing, 
temperature, representation on hardware, etc. Since we do not want to 
model all these complex dependencies, we may instead represent them 
by nondeterministic choices. The nondeterminism 
of concurrent systems usually arises as an abstraction of time. 
Similarly nondeterminism is also a means of increasing the level of 
abstraction when describing sequential programs \cite{c:85, c:130}, and as a 
way of indicating a ``don't care''  attitude as to which among a 
number of computational 
paths will actually be utilized in a particular evaluation \cite{c:30}.

 The variety of approaches referred to above 
indicates the possible difficulties in gathering all the pieces into 
one uniform theory, let alone a short presentation. 
In this paper we are concerned with algebraic specifications and 
hence will consider only a part of the whole picture of 
nondeterminism. As far as the basic notions related to nondeterminism 
and the associated algebraic formalisms are concerned, the paper 
is by and large self-contained. Only occasionally refererences to 
other areas presupposing some prior knowledge will be made.

 In section~\ref{se:one} the basic concepts involved in the study of
nondeterminism are introduced. Sections~\ref{se:two}-\ref{se:cont}
discuss the semantic issues, and \ref{se:reasoning}-\ref{se:rew}
reasoning with nondeterminism. The main alternatives for the
interpretation of nondeterministic operations, homomorphisms between
nondeterministic structures, and equivalence of nondeterministic terms
are sketched in section~\ref{se:two}. Sections~\ref{se:init} and
\ref{se:terminal} discuss various proposals for, respectively, the
initial and the terminal semantics. In section~\ref{se:cont} we make some comments
on the continuous semantics of nondeterminism and the problem of
solving recursive equations over signatures with binary
nondeterministic choice.  Section~\ref{se:reasoning} presents the attempts at reducing
reasoning about nondeterminism to reasoning in first order logic and
then gives an example of a calculus dealing directly with
nondeterministic terms. In section~\ref{se:rew} rewriting with nondeterminism is
discussed: primarily, as a means of reasoning, but also as a means of
assigning operational semantics to nondeterministic specifications. Section~\ref{se:sum}
concludes the overview.

\section{Basic concepts}\label{se:one}
In this section we present informal 
definitions of the basic concepts and distinctions involved in the 
study of nondeterminism. 

\para{Nondeterminism and nondeterminacy}
 Roughly speaking, nondeterminacy 
concerns {\em syntax}, nondeterminism {\em semantics} \cite{c:21}. The constructs 
which always yield unique result are {\em determinate}, those which 
may yield different results when invoked several times 
{\em non\-deter\-minate}. The presence of a 
nondetermi\-nate construct in an expression does not force the 
cor\-re\-sponding operation to be nondetermin\-istic. Determinacy implies 
determinism, but nonde\-terminacy does not necessarily imply 
non\-deter\-minism and, as observed in \cite{c:18}, the problem whether a 
non\-determinate term is deter\-mi\-nistic or not is, in general, undecidable. 
We are primarily concerned with the intentional 
nondeterminism originating from the presence in the language of some 
constructs which have nondeterministic semantics. 

\para{Nondeterminism and underspecification}
When developing a software system 
in a number of refinement steps, we are often interested in 
specifying the functionality of the system uniquely, but only with 
respect to some relevant properties. 
That is, each model of the specification is a standard 
(deterministic) structure, but we do not identify one unique model. We 
then speak of underspecification. Later in the development process we 
may add more properties, whenever we find it appropriate, 
and so restrict the model class. Thus underspecification,
like nondeterminism, provides a means of abstraction. It 
bears a resemblance to nondeterminism in that it leavs open the 
possibility of choosing among several admissible models. The 
important difference between the two notions may be roughly expressed 
thus: underspecification admits a choice between different models, but 
nondeterminism admits choices within one model. While 
underspecification fits into the concepts of classical logic and 
model theory smoothly, the treatement of nondeterminism leads to 
complications and, typically, requires introduction of non-standard 
features both into the models and the logic. For this reason some 
researchers postulate the use of underspecification as the 
primary, if not the only, means of abstraction. Others consider it 
insufficient and try to design formalisms which capture the 
phenomenon of nondeterminism as distinct from underspecification 
\cite{c:LR, c:94, c:118, c:132}.

\para{Representational vs. ``real''  nondeterminism}
There are essentially two reasons 
why one might want to include the concept of nondeter\-minism in the 
traditional algebraic specification methods:
\begin{enum}
\item {\em Real} nondeterminism.\\
The system being specified 
really is nondeterministic --  its behavior is not fully 
pre\-dict\-able, nor fully reproducible, no matter how detailed our 
knowledge of its initial state.
\item {\em Representational} (or {\em pseudo-}) nondeterminism \cite{c:64, c:121, c:130}.\\
The behavior of the system 
being specified may be fully predictable in its final 
imple\-mentation (i.e. deterministic), but it may not be so at the 
level of abstraction of the specification.
\end{enum}
Though many think of 
representational nondeterminism as identical to 
under\-specifi\-cation, they turn out to be technically and 
conceptually quite distinct (as we shall see shortly). 

Whether the world {\em really} is 
nondeterministic or not we leave to the physicists and 
phi\-lo\-sophers to ponder. A sequential computer system {\em in isolation}
 certainly is deterministic: When started from a particular state 
(given in full detail) twice, both executions will demonstrate 
identical behavior. Possible sources of perceived nondeterminism lie 
only in the unpredictability of the environment such as hardware failures or human 
factors. Considering all such factors as parts of the total state 
given in full detail may obviate the perceived nondeterminism, 
but leads to undesirable complexity and is possible only 
in principle.

The primary argument in favor of accepting nondeterministic operators 
is instrumental, and identical to the credo of the abstract data type 
community: One should specify a system {\em 
only in such detail that any implementation satisfying the 
specification also satisfies the user, and no more.} It turns out 
that nondeterministic operators ease the process of specifying 
systems by allowing one to disregard irrelevant aspects  -- 
be they external influences or implementation details --  
and thus reducing the danger of over\-specification resulting from 
technical rather than methodical reasons. 

For purposes of discussion it may be convenient to further identify 
three variants of representational nondeterminism: 
(1) abstraction from hidden state, (2) 
abstraction from time, and (3) abstraction from external entities. 
Though these may be dealt with uniformly, they have often been 
considered distinct. In particular, the introduction of 
nonde\-terminism as a result of 
abstraction from {\em time} is usually taken as a given in the process 
alge\-bra community without thereby necessesarily accepting 
abstraction over {\em state} as requiring nondeterminsm for specification purposes.

 How does this use of nondeterminism differ 
from the usual notion of under\-specifica\-tion? Consider for a 
moment a user-defined choice function $\sqcup$ from sets of 
integers to integers, returning one of the elements of the set:

 For instance, $\sqcup(\{0,1\})$ may return 
either 0 or 1. If choice were just an under\-specified 
function, then we would have that $\sqcup(\{0,1\})=\sqcup(\{1,0\})$, 
since the arguments of the function are equal (though not 
syntactically identical) in the two terms. In practical terms, this 
would require the choice operator always to return the same value 
when applied to a particular set. I.e., $\sqcup(\{0,1\})$ is always 0, or always 1.

 However, this kind of underspecification does 
not allow for abstraction from (conceptually) invisible entities that 
might influence the choice (such as a hidden state, timing or 
interaction with a human being). E.g., if sets were implemented 
as sequences, with new elements always added to the 
front of the sequence, this underspecified description of the choice function would disallow a 
simple imple\-men\-tation of choice by picking the first element 
of the sequence, since 
such an implementation would sometimes return the value 0, sometimes 
the value 1, when applied to the set $\{0,1\}$, depending on which of the 
two elements was added first. If we were to treat choice 
as a nondeterministic operator, on the other hand, then such a 
straightforward implementation (though deterministic) would be quite 
acceptable, both formally and according to the usual intuition 
about the requirements of an operator picking some element 
from a set \cite{c:107, c:132}.

 Similarly, if the implementation of the choice 
function asked a human operator to pick an element then one would 
encounter the same difficulty.
A specification needs to abstract from the unpredictability of such human choices, and 
nondeterminism is the right concept for doing that.

 And similarly again, if the choice depended 
upon timing properties (e.g. the set was distributed among a number of processors, and the choice function simply 
queried them all, returning the first (in terms of time) value 
returned to it by one of these processors) the abstraction from timing properties would introduce a seeming 
nondeterminism.

\para{Bounded and unbounded nondeterminism}
 {\em Bounded} nondeterminism refers 
to the case where every terminating computation has only a finite 
number of possible results; {\em unbounded}  -- to the one where 
the set of the possible results may be infinite \cite{c:Hes,c:54}.

It may be argued \cite{c:30, c:54} 
whether unbounded nondeterminism has a plausible computational 
interpretation. A deterministic program $P$ which takes a natural 
number $n$ as input and outputs a natural number $m$
 corresponds to a partial recursive function. The relation 
 \[
  R_{P}(n,m) \iff P(n)=m
  \] 
\noindent 
is recursively enumerable (RE), and 
the subset $L_{P}$ of natural numbers for which $P$ 
does not terminate is co-recursively enumerable. For a nondeterministic 
program $P$, the input-output relation $R_{P}(n,m)$ is also RE, but when the involved 
nondeterminism is unbounded $L_{P}$ is much more 
complex than co-RE. Firstly, (non-)termination cannot be guaranteed 
and $L_{P}$ is the set of those inputs on which 
$P$ {\em may} not terminate. Then it is shown in \cite{c:25} that for 
erratic (see below) unbounded nondeterminism $L_{P}$ has the 
complexity $\Sigma_{1}^{1}$.
 This either presents a serious challenge to the Church-Turing 
thesis and the classical notion of computability or, perhaps, 
discredits unbounded nondeterminism as a notion without computational 
relevance. Nevertheless, even if one might agree that the notion 
of unbounded nondeterminism is not feasible from the 
implementation point of view, it may even so provide an invaluable 
abstraction mechanism at the specification level.
 
Unbounded nondeterminism creates severe difficulties in models based 
on fixed point semantics because, unlike bounded nondeterminism, it 
is not continuous in the standard constructions of power domains. 
However, it should be observed that noncontinuity is 
not caused by the nondeterminism, but rather by the unboundedness. 
Noncontinuity may also arise in a determinate language, for instance, 
in a language admitting quanti\-fication over infinite sets \cite{c:18, c:22}.

\para{Biased agents }
 The paradigmatic concept of 
nondeterminism is probably that of arbitrary choice. Choosing 
nondeterministically between $a$ and $b$ there is a possibility 
that we get $a$ and also a possibility that we get $b$. 
The choice may be influenced by additional factors which 
never\-theless leave it, to some extent, undetermined. If this is the 
case we may speak of the ({\em agent} making the) choice being {\em 
biased}. 

The most extensively studied 
case of such agents involves bias with respect to possible 
termination. {\em Erratic} choice \cite{c:24} is completely arbitrary -- 
 it may happen that such a choice will lead to a nonterminating 
computation and it may happen that it will eventually produce some 
result. {\em Angelic}
 choice, on the other hand, will always avoid branches which may lead 
to nontermination. If there is a computational path leading to a 
successful result, angelic nondeterminism will guarantee that such a 
path will be found. Finally, a {\em demonic}
 choice will do the opposite and always follow the path, if such 
exists, leading to a nonterminating computation.

 
In terms of implementation, erratic nondeterminism is the least 
problematic. A choice may be performed locally without consideration 
of the possible consequences of the choices made. It may be also 
thought of as an unpredictable environment beyond the control 
of the program. An operational intuition of angelic 
nondeterminism \cite{c:25} can be a system which, whenever a choice 
is to be made, spawns several new processes, one for each among 
the possible results of the choice. The first process to terminate 
causes all other processes to stop as well. The demonic case can be 
analogous except that {\em every}
 process must terminate if the whole computation is to terminate. 
Demonic nondeterminism is in \cite{c:21} called {\em backtrack} 
nondeterminism  -- 
it is there thought of as a system which makes a choice and follows 
the path until it terminates. If it does, the system backtracks to 
the point at
 which the last choice was made and follows another path. It will 
terminate only after having checked that all possible choices lead to 
terminating computations.

 The terms erratic, angelic and demonic are used 
not only to refer to the termination aspect, but, generally, to the 
situations where nondeterminism involves arbitrary choices where the 
results are either ``desirable'' 
 or ``undesirable,''  e.g., with respect to 
definedness. 

 The first version of angelic nondeterminism 
\cite{c:84} was related to this kind of preference for ``desirable'' 
 behaviour. It was local (like the erratic one) in the sense that it 
chose among its arguments looking only at their values rather than at 
the consequences of its own choice. If both arguments were well 
defined (completed computations) any of them might have been chosen 
erratically, but if any of the 
arguments was undefined the other one was chosen. 

 This is an example of the {\em value} bias 
\cite{c:110} where every agent may have its own preference as to which 
values to choose. Such a bias can be modeled 
by a partial order on the values expressing the preferences. An 
agent presented with the choice between $a$ and $b$
 first considers whether any of the values is to be preferred (is 
greater in the ordering), in which case this value is selected. 
Otherwise the choice is arbitrary. For instance, the ordering for the 
angelic agent in the last paragraph would be the {\em 
flat} partial order: $a\leq  b \iff a=\perp \lor\ a=b$.

 Another form of a bias is {\em fairness}. If an 
erratic agent has infinitely many occasions to choose between $a$
and $b$ it may happen that it will always choose $a$. A fair 
agent will eventually choose also $b$.\footnote{ 
This is known as {\em unbounded} fairness. There 
are many different notions of fairness \cite{c:25, c:99}, but we 
do not focus on them here.}
 There is a close connection between fair choice and unbounded 
nondeterminism as the well-known example illustrates \cite{c:3, c:30, c:99}: 
\\[1ex]
\hspace*{2em} $b := \true$ ; \\
\hspace*{2em} $x := 0$ ; \\
\hspace*{2em}  {\bf while} $b$ {\bf do} \\
\hspace*{3em} $b := \false\ \ \ch\ \  x := x+1$ ;  \\
\hspace*{2em} {\bf od}; \\[1ex]
If $\sqcup$ denotes erratic (demonic) choice this program may (will) not 
terminate. Any number may be returned by a terminating (erratic) 
computation. If $\sqcup$ is fair (in this case it means also angelic) then 
the program will {\em always} terminate. There is no upper bound on the 
number of iterations before this will 
happen, though, so any natural number may be returned as the value of 
$x$. This means that a ``solution'' to the fairness problem would 
also provide a mechanism to implement 
unbounded nondeterminism. 

Many subtleties arise in this connection: the 
distinction between {\em strong termination} 
(which requires an upper bound on the number of 
iterations) vs. {\em weak} (where no such bound exists) \cite{c:5}, {\em tight}
implementation (which produces all the results prescribed by the 
specification) vs. {\em loose} (which only needs to produce some of them) 
\cite{c:21, c:99} and, of course, various kinds of fairness ranging from the 
``ideal'' 
 fairness as in the example above to forms of computable fairness 
where the bound on the delay in selecting any of the alternatives is 
determined by some computable function. The latter is shown in \cite{c:25} 
to have complexity $\Sigma_{1}^{0}$, i.e., essentially the same as 
functions computable by deterministic 
programs. (Thus fairness will restrict the functions ``computable''  
by a nondeterministic program.)\par 
As a final example of biased agents we mention {\em probabilistic} 
nondeterminism \cite{c:68, c:108, c:111, c:81}. Here every choice is made with 
some probability distribution $P$ which may depend only on the 
values (e.g., whenever a choice between $a$ and $b$
is to be made, $P(a)=1/3$ and $P(b)=2/3$), 
or also on the agents making the choice (so that 
$P_{M}(a,b)$ for an agent $M$ may differ from $P_{N}(a,b)$ for another 
agent $N$.) Of course, the formalism for the description, as well as the 
models, of probabilistic nondeterminism are considerably more complex 
than the formalisms and models of non-probabilistic nondeterminism. 
They are probably more appealing to the community interested in 
probabilistic algorithms than to workers in the field of 
formal specifications and abstract data types.   

\para{Singular and plural} 
In deterministic programming the 
distinction between call-by-value and call-by-name semantics is 
well-known. The former corresponds to the situation where the actual 
parameters to function calls are evaluated and passed as values. The 
latter allows also parameters which are function expressions, 
passed by a kind of Algol copy rule \cite{c:113}, and which are 
evaluated only when a need for their value arises.

The nondeterministic 
counterparts of these two notions are what \cite{c:110} calls {\em singular} 
and {\em plural} semantics of parameter passing. 
This terminology reflects the meaning of the nondeterminate 
terms as representing sets of possible results. Evaluation of such a term yields a 
unique result, hence when evaluation of the argument is required at 
the moment of the call it represents a single value. When a term is 
passed by some variant of the textual copy rule and several 
evaluations of it in the body of the operation can happen 
independently of each other, then we can picture the situation as 
passing the whole set of possible results where each reference to the 
parameter name picks (independently) one among the possible results.

This distinction, with its operational flavor, has some relation to
the bias with respect to termination. Interpreting singular vs. plural
analogously to call-by-value vs. call-by-name, the latter will
terminate more often than the former, since it does not necessarily
require evaluation of all its arguments. However, the analogy is not
so perfect and the distinction
influences heavily the actual results produced also by terminating computations.

\para{Miscellany.} 
Among other, more particular 
distinctions which may occasionally be referred to, we have:
\begin{itemize}
\item Closely related variants of the plural-singular 
distinction can be encountered under the names call-time-choice vs. 
run-time-choice  \cite{c:26, c:49, c:50}, inside-out (IO) vs. outside-in (OI) 
\cite{c:34, c:35}. The different names reflect slight differences in meaning 
of the concepts. Except where we are entering into a
 more detailed discussion of this distinction (section 7) we will adopt the 
terminology from \cite{c:110} (taking the risk of abusing it a bit for the sake 
of a more intuitive exposition). 
\item {\em Weak} vs. {\em strong} \cite{c:110}. 
Weak nondeterminism means that, although some internal parts 
of a computation may happen nondeterministically, the eventual result 
is uniquely determined by the input. For instance, terminating confluent 
rewriting of a term may apply different rules (chosen nondeterministically) 
but will always arrive at the same normal form; a 
term may be called weakly nondeterministic if it is nondeterminate 
and deterministic. Strong nondeterminism is, of course, the 
nondeterminism of operations capable to produce distinct results on
different invocations with the same arguments.
\item {\em Tight} vs. {\em loose} \cite{c:99, c:21, c:110}. 
This distinction concerns the relation between two, possibly 
nondeterministic, structures. If $M$ is one of them and displays 
some nondeterminism then $N$
 is said to be tight if it displays exactly the same amount of 
nondeterminism, and it is loose if its nondeterminism is, possibly, 
more restricted than that of $M$. For instance, if $M$ is a 
specification then, typically, its implementation $N$
 will be allowed to decrease the nondeterminism of some operations 
(loose). Similarly, if $M$ is a programming language with 
nondeterminate constructs, then we may think of a (loose) 
deterministic implementation $N$ of $M$
 as being correct if every operation in $N$ returns a result which 
is among the possible results of the corresponding operation in 
$M$.  
\item {\em Restrained} vs. {\em unrestrained }\cite{c:110}. 
The former is nondeterminism of single programming constructs 
 -- ``choose an arbitrary number,'' and the 
latter is nondeterminism allowing choice of different execution 
paths  -- ``{\bf goto} label1 {\bf or} 
label2.'' The latter can be easily implemented using the former. 
Nevertheless, the names come from the fact that denotational models 
of the latter are much more complex and require power domain 
construction over function spaces with a non-flat ordering.  
\end{itemize}

\para{Notation}
 A specification $SP$ is a pair $(\Sigma,\Pi)$ of 
signature $\Sigma$, and a set $\Pi$ of $\Sigma$-formulae in some language which will depend on the 
context. The set of ground terms over $\Sigma$
 will be denoted $\GTerms$, and $\XTerms X$ will denote terms with 
 variables from the set $X$. Terms may be determinate or nondeterminate 
 -- when speaking of their interpretation we will say {\em 
``function'' } whenever a deterministic operation is 
meant, and {\em ``operation''} whenever the term may 
denote a nondeterministic operation. For $t\in\XTerms X$, we will 
let $\res t$ denote the set 
of its possible results, possibly with a superscript, as in 
$\res{t^{A}}$,  to indicate the structure $A$ in which $t$
 is interpreted. 

Nondeterministic choice is 
denoted by $\ch$. Sometimes it will denote binary 
choice, written  $x\ch y$, but usually its argument will be a set 
 -- either because the profile of $\ch$ in $\Sigma$ declares it 
so, or because the appropriate axioms of commutativity, associativity 
and idempotency are given. For the  operator with a set argument the notation 
$\ch.\{x,y\}$ will be used. 

Equality, as a primitive of the language, is written in the infix 
notation,  $x=y$; 
The symbol $\syeq$  indicates syntactic identity of its arguments. 
 
 
An upper case letter such as ``$A$''  usually 
denotes a set or a model with carrier $\Car A$. 
(The latter notation is also occasionally used for the cardinality 
of a set. We expect  no confusion to arise from this overloading of 
notation.) 
$\PSet(A)$ is the power-set of $A$,  $\PSet^{+}(A)$ the set of its 
non-empty subsets.  $\PSet A$ will denote (some variant of) a power-set 
structure. 

%%%%%%%%%%%%%%%%%%%%%%% Section 2

\section{Semantic preliminaries}\label{se:two}
The algebraic approach to 
nondeterminism is dominated by the use of power-set structures. We 
use the name ``power-set structure'' 
 (algebra, model) as the generic description of most algebraic models 
of nondeterminism. In particular, {\em power algebras} are just a 
special case of power {\em set} algebras. We include here also the {\em 
function oriented} and {\em relational}
 constructions since they are closely related to what one would 
naturally associate with the expression ``power-set 
structure.'' However, there is no standard definition of this notion. 
In this section we sketch the main alternatives of modeling operations and 
homomorphisms using power-set structures. The following definition 
will be used extensively:
\begin{Definition}  
We say that a function $f:\PSet(A)\into\PSet(B)$ is  
\begin{enum}
\item {\em additive}, written $f:\PSet(A)\addinto\PSet(B)$,   iff   
$\forall S\in\PSet(A) : f(S)=\bigcup_{s\in S}f(s)$,
\item {\em strict}, written $f:\PSet(A)\strinto\PSet(B)$, iff 
$f(\es)=\es$, and
\item {\em preserves singletons}, written 
$f:\PSet(A)\singinto\PSet(B)$, iff $\forall S\in\PSet(A):\Car 
S=1\impl\Car{f(S)}=1$.
\end{enum}
Functions satisfying both 1. and 2. will be indicated by 
$f:\PSet(A)\addstrinto\PSet(B)$.
\end{Definition}

\subsection{Operations ...} 
The carrier of a power-set algebra $\PSet A$ is (usually) the
power-set of some ({\em underlying} or {\em basis}) set $A$. In a
many-sorted context, for each sort $S\in\Sorts$, the carrier of sort
$S$ is $\PSet(S^{A})$ or $\PSet^{+}(S^{A})$. (In the notation we usually drop the sort
indexing -- it is always implicitly present.) The elements of $A$ will
be called {\em individuals} -- interpretation of terms in $\PSet A$ is
usually based on the interpretation of variables as individuals
(singular semantics \cite{c:110}). The interpretation of a nondeterminate
operation $f:S_{1}\times\ldots\times S_n\into S$ offers several choices.

\para{Functional models: $f^{A}= \{f_{z}: S_{1}^{A}\times\ldots\times S_n^A\into 
S^{A}\}_{z\in Z} $}
 Here the carrier is the set $A$ 
rather than its power-set. Every $f$ is interpreted as a set 
$\{f_{z}\}_{z\in Z}$ of deterministic functions. Operationally it may 
mean: whenever $f$
 is to be applied, first some $i$ is chosen and then the 
(deterministic) function $f_{i}$ is applied, i.e., all 
nondeterminism is resolved at the beginning of the computation.  

A possible argument against the functional model is that it is not 
fully abstract. Instead of looking at the input-output relation which 
gives the abstract view of a program (specification) it looks inside 
it and distinguishes models with the same observable behavior, \cite{c:58, c:59}: 

\begin{Example}\label{ex:func} 
Let $A$ and $B$ be two models of an operation $f:S\into S:$
\[ \begin{array}{c@{\ \ \ \ \ \ \ \ }l}
\multicolumn{2}{c}{ S^{A}\ =\ \{0,1\}\ =\ S^{B}} \\
 f^{A}=\{f_{0}, f_{1}\} &  f^{B}=\{f_{2}, f_{3}\} \\
 f_{0}(0)=f_{0}(1) = 0 & f_{2}(0)=0,\  f_{2}(1) = 1 \\
  f_{1}(0)=f_{1}(1) = 1 & f_{3}(0)=1,\  f_{3}(1) = 0
  \end{array}
\]
 For any input, $f^{A}$ and $f^{B}$ can return the same 
result, and hence might be called indistinguishable. The above 
semantics, however, would claim that $A$ and $B$
 are different because both computations are performed in different 
ways.
\end{Example}

This vice may become a virtue if the way in which 
operations are computed matters. It is easy to abstract such a 
structure of computations and look only at the result sets produced 
by a nondeterministic operation \cite{c:126}. 

The model reflects also the fact 
that each computation of any program produces a unique result  --  
observing the results produced in {\em one}
 execution of a program does not supply sufficient information to 
decide whether we run a nondeterministic $f$, which happened to 
choose an $f_{i}$, or whether we run a deterministic 
$f_{i}$. Thus  
\[ 
m_{i}\in f(n) \iff \exists f_{i}: f_{i}(n) = m_{i}
\]   
 In this view there is, in general, 
no deterministic program equivalent to a nondeterministic one. Both 
produce unique results in every computation on a given input, but 
all computations of the former produce the 
same result, while different computations of the latter can produce 
different results. In terms of the automata theory this amounts to 
viewing each nondeterministic finite state machine 
$N\!M$ as a set of deterministic machines $\{D\!M_{z}\}_{z\in Z}$, each accepting 
exactly one string from the language of $N\!M$.

This functional approach has 
received relatively little attention in the literature. The domains 
of indexed sets used in \cite{c:9} instead of power domains remind 
one of indexed functions. A more elaborate investigation of the 
functional models is reported in \cite{c:126} where the relationships to the 
next kind of models are studied as well. We will denote functional 
models by $\FMod$.

\para{Multialgebras: $f^{A}: S_{1}^{A}\times\ldots\times S_n^A\into \PSet(S^{A})$} 
This is the most common approach \cite{c:102, c:64, c:53, c:58, c:93,
c:8, c:126}. The arguments to the operations are individuals and the
result is the set of possible outcomes. Thus operations are modeled as
deterministic set-valued functions.

This view corresponds to the equivalence 
of nondeterministic and deterministic (finite state or Turing) 
machines. The central point of this equivalence is the definition of 
languages accepted by the former in which nondeterminism is 
eliminated: a nondeterministic machine $N\!M$ accepts a string 
$s$, $s\in\Lang(N\!M)$, iff there exists an accepting 
computation starting on $s$. Writing {\sf S} for the initial state, 
{\sf Y} for a final (accepting) state, and $\epsilon$ for the empty 
string, we have
\[
 s\in\Lang(N\!M) \iff \exists\ {\rm computation\ }C:({\sf S},s)\rew^{C}({\sf 
 Y},\epsilon)
 \]
The existential quantifier 
eliminates all nondeterminism  --  it does not matter any more 
which computation is performed; an accepting computation $C$
 either exists or not, and the language of $N\!M$ is uniquely defined. 
Hence, an equivalent deterministic machine $D\!M$ can be constructed by 
``dovetailing''  all possible computations of $N\!M$. 
Analogously, if $f$
 is a (nondeterministic) multioperation, the result set $f(n)$ 
 can be computed deterministically by evaluating (``dovetailing'') 
 all possible computation paths, as it is done 
for the Turing machines. 

Composition of multioperations is defined 
using the following simple fact \cite{c:34, c:106}:
\begin{Claim}\label{prop:stradd} 
For each $f:A\into\PSet(B)$ there exists a unique 
$f^{\PSet}:\PSet(A)\addstrinto\PSet(B)$ (strict, additive) such that 
the following diagram commutes:
\[ \scol{-1pc}
\diagramcompileto{00Cc}
 & A \dlto_{\{\_\}} \drto^{f} \\
\PSet(A) \rrto^{f^\PSet} & & \PSet(B)
\enddiagram \]
\end{Claim} 
 $\{\_\}$ denotes the canonical embedding sending 
every element to the singleton set containing it. Thus composition is defined as: 
$g(f(x)) = g^{\PSet}(f(x)) = \bigcup_{e\in f(x)}g(e)$. 
Also here it is natural to interpret the carrier as the set 
$A$ rather than its power-set, but the canonical embedding $\{\_\}$ and 
additivity of the operations make the transition between the two very 
easy. We will denote multimodels by $\MMod$.

Here the two models from example~\ref{ex:func}
would be identified, since both $f^{A}$ and $f^{B}$
applied to any argument return the set $\{0,1\}$. 

In most cases, one lets an operation $f$ 
map $A$ to $\PSet^{+}(B)$ rather than $\PSet(B)$. The former 
corresponds to the {\em total} while the latter to the {\em partial} 
models in which $f(a)=\es$ indicates that $f$ is undefined on $a$. 
With the above definition of 
composition this partial interpretation implies angelic 
nondeterminism.

\begin{Example}\label{ex:angelic} 
Consider a two-sorted algebra with
 $N = \{0,1,2\}$ and $S=\{a,b,c\}$, and with operations 
$f:N\into S,\ g:S\into N$  such that:
\[ \begin{array}{l@{\ \ \ \ \ \ \ }l}
f(0) = \{a,b\} & g(a) = \{0,1\} \\ 
f(1) = \{a,c\} & g(b) = \{2\} \\ 
f(2) = \es  & g(c) = \es \end{array}
\]
Then \\
\hspace*{2em}$ g(f(0)) = \{0,1,2\} $ \\
\hspace*{2em}$ g(f(1)) = g^{\PSet}(\{a,c\}) = \{0,1\}\cup \es = \{0,1\} $ \\
\hspace*{2em}$ g(f(2)) = g(\es) = \es $ 
\end{Example}

To obtain more flexibility in modeling biased 
nondeterminism with multialgebras some additional constructions in 
the specification language are needed, analogous to those for partiality in the deterministic case, 
e.g., the bottom element $\perp$ \cite{c:77, c:63, c:91}, or definedness 
predicate \cite{c:21, c:18, c:59, c:58}.
Focusing on the inherent problems of nondeterminism we will
not pay much attention to the additional complications introduced by
partial operations. 

 Although the classes $\MMod$ and 
$\FMod$ are not isomorphic there is a strong sense of correspondence 
between the two. Taking ``equivalence'' to mean the same result sets on the 
same arguments for each operation, we have:
\begin{Claim}\label{prop:26}{\rm \cite{c:127}.} 
Every functional algebra $F$ 
determines an equivalent multialgebra $M$ and for every multialgebra $M$ there is an 
equivalent functional algebra $F$.
\end{Claim}
\begin{Proof}
Let $F$ has an operation $f^A=\{f_1,f_2,...\}$. Define the multialgebra $M$ by
\begin{itemize}\MyLPar
\item $\Car M = \Car F$
\item $f^M(x_i) =\bigcup_{f_{k}\in f^{F}} f_k(x_i)$.
\end{itemize}
The converse is analogous, but not constructive. Take $\Car F=\Car M$
and for each $f\in\Sigma,\ x_i\in\Car M$ (of appropriate sort), let
$\kappa_{f,x_{i}}$ denote the cardinality of the set $f^M(x_i)$, and
$\kappa_f=\bigcup_{x_{i}}\kappa_{f,x_{i}}$. Then, for each $x_i$, there is a surjection
$\alpha_{x_{i}}:\kappa_f \into f^M(x_i)$, and we can define
\begin{itemize}\MyLPar
\item $f^F = \{f_k : k\leq\kappa_f\}$, with $f_k(x_i) = \alpha_{x_{i}}(k)$.
\end{itemize}
(Note that $F$ isn't unique and that the axiom of choice is needed to actually determine it.)
\end{Proof}

Treatment of partiality in a functional model 
will be quite different from that illustrated in example~\ref{ex:angelic}. Unless 
we introduce a $\perp$
 element (or a definedness predicate) explicitly, there will be no 
default interpretation of undefinedness (such as the empty set) in 
the carrier of a functional model. 

Other consequences of the 
multialgebraic interpretation can best be explained by contrasting it 
with the third possibility: 

\para{Power algebras: 
$f^{A}:\PSet(S_{1}^{A})\times\ldots\times\PSet(S_{n}^{A}) \into 
\PSet(S^{A})$}
Here each function takes a tuple of sets as 
an argument and returns a set as the result. There are several
possible ways to interpret this:
It may mean that each element of the result set is a
possible outcome of applying the operation to {\em any} element of the
argument set.  In other words, $f(\{0,1\})=\{a,b\}$ would be just an
abbreviation for $f(0)=\{a,b\}$ and $f(1)=\{a,b\}$.

A more reasonable interpretation would be to say that the result set comes from
applying the operation to the {\em whole} argument set. This still leaves two
possibilities. \\[1ex]
a) All operations are strict and additive.
Under this interpretation
a power algebra is just a more concise expression of a multialgebra,
as the following straightforward consequence of the
proposition~\ref{prop:stradd} shows ($[A\into B]$ denotes the partial
order of functions from $A$ to $B$ ordered pointwise):

\begin{Claim}\label{prop:pointwise} 
$[A\into \PSet(B)] \iso [\PSet(A)\addstrinto \PSet(B)]$.
\end{Claim}

\noindent
Observe that this proposition gives a statement for one-argument
functions. Thus, we may conclude that $[A_1\times A_2\into
\PSet(B)]\iso [\PSet(A_1\times A_2)\addstrinto \PSet(B)]$. 
But $\PSet(A_1)\times\PSet(A_2)\not=\PSet(A_1\times A_2)$, so this
does not seem to apply to our power algebras. Nevertheless, for functions strict
and additive in {\em all} arguments we have \cite{c:Mes}:
\begin{Claim}\label{prop:pointwiseb}
$[\PSet(A_1)\times\ldots\times\PSet(A_n)\addstrinto\PSet(B)] \iso
[\PSet(A_1\times\ldots\times A_n)\addstrinto\PSet(B)]$
\end{Claim}
\begin{Proof} 
An $f^{\#}:\PSet(A_1\times A_2)\addstrinto\PSet(B)$, determines a
function $f^\PSet:\PSet(A_1)\times\PSet(A_2)\addstrinto\PSet(B)$ which
is essentially given by $f^\PSet(x,y)=f^\#(\langle x,y\rangle)$.
Strictness and additivity in {\em all} arguments follows from the
general formulation : $f^\PSet(X,Y) =
\bigcup_{x\in X,y\in Y} f^{\#}(x,y)$. Similarly, given an $f^\PSet$,
we can get back defining $f^{\#}(X\times Y)=\bigcup_{x\in X, y\in
Y}f^\PSet(x,y)$. We then have that for all $X\subseteq A_1, Y\subseteq
A_2:f^\PSet(X,Y)=f^{\#}(X\times Y)$.
\end{Proof}

Strictness of $f^{\#}$
corresponds to strictness of $f^\PSet$ in {\em all} arguments, since
\[ \begin{array}{ccccccc}
\es & = & f^{\#}(\es) & =& f^{\#}(\es\times Y) & =& f^{\#}(X\times \es) \\
    &   &             &  &   =                 &  &  = \\
 &  &             &  & f^{\PSet}(\es,Y)    & =& f^{\PSet}(X,\es)
\end{array} 
\] 
b) The other (and from now on the only) meaning is that every element
of the result set is a possible outcome of applying the operation to
the argument set and operations are not necessarily additive.  
Without any additional conditions such a
definition begs the whole question of nondeterminism because what we
obtain is a deterministic structure which just happens to have a
power-set as the carrier. In particular, there is no distinction
between elements, or 1-element sets, and other sets. An operation $f$
may, for instance, be such that $f(\{0,1,2\}) = \{0\}$ and $f(\{0\}) =
\{0,1\}$.  This is counterintuitive \cite{c:3a, c:103} because one expects that
an increase in the nondeterminism of the arguments to an operation
should not result in a decreased nondeterminism of the result.

To meet the intuitive 
understanding one would require that the operations in a power 
algebra be $\subseteq$-monotonic. $\subseteq$-monotonicity does 
not imply additivity, and so proposition~\ref{prop:pointwise} does 
not yield an isomorphism with multialgebras. Considering
non-additive functions between power-sets offers new possibilities. 
If we aim at plural semantics of parameter passing \cite{c:110, c:130} we are 
forced to allow the arguments of 
functions to be sets (and to let variables refer to sets rather than 
individuals). 

\begin{Example} 
Let $f$ be the operation \\[1ex]
\hspace*{2ex}
$f(x) = {\ \ \rm if\ }x=x{\rm\ then\ }0{\rm\ else\ }1$. \\[1ex]
In any multimodel ($x$ will 
refer to an individual and) the result set of $f$ will be $\{0\}$
for all $x$. In particular, 
$f(a\ch b)=\{0\}$. Some authors \cite{c:77, c:53} focus on the purely semantic issues, i.e., do 
not consider any specification language. But by adopting the 
multimodel of operations they are forced to adopt the singular 
semantics of the operation symbols. \\
If, on the other hand, we take 
$f$ as mapping sets to sets, we obtain \\[1ex]
\hspace*{2ex}
$f(a\ch b) = {\ \ \rm if\ }(a\ch b = a\ch b){\rm\ then\ }0{\rm\ else\ 
}1$\\[1ex]
which may give $f(a\ch b)=\{0,1\}$.
\end{Example}

Actually, the last equality does 
not follow by itself in a power model, but depends further on the 
interpretation of the equality $a\ch b = a\ch b$
 (which may be interpreted as element- or set-equality). We discuss 
this further in sections~\ref{sub:equiv} and \ref{se:rew}. The singular semantics can be obtained, 
according to propositions~\ref{prop:pointwise},~\ref{prop:pointwiseb}, 
if we impose the additional restriction of additivity. 
Thus power algebras, but not 
multialgebras, give us the possibility of defining both singular and 
plural semantics.


The reasons why this approach is relatively unpopular in spite of its 
apparent generality are probably mostly pragmatic and similar to the 
reasons why call-by-name semantics has been superseded by 
call-by-value semantics in the deterministic setting (besides the
fact that additive function spaces have nicer formal properties). It 
may be argued that programs written in terms of 
call-by-value are significantly clearer and more tractable 
than those using call-by-name. 
It should be also observed that defining the carrier as the set of all (also
infinite) subsets of the basis set, will give us, when the basis set is infinite, 
only uncountable models where most elements are 
unreachable.

Power models will be denoted by $\PMod$.

\para{Relational models:  $f^{A}\subseteq 
S_{1}^{A}\times\ldots\times S_{n}^{A}\times S^{A}$}
Although relational structures are 
well known in  universal algebra \cite{c:27, c:80, c:79} they have not quite 
found their way into
 the world of algebraic specifications, where the intuition of 
functional application and its result plays the central role. Use of 
relations in semantic definitions is made in \cite{c:99, c:7, c:93, c:25, c:18}, 
and, in a categorical setting, in \cite{c:119}. In so far as input-output behavior 
is concerned the relational models are isomorphic 
to multimodels. 

\begin{Claim}\label{prop:29} 
$[A\into\PSet(B)]\iso [A\into (B\into \bool)]\iso [A\times 
B\into\bool]\iso \PSet(A\times B)$.
\end{Claim}

\noindent
With the relational product as the definition of composition, one 
obtains angelic nondeterminism as with multialgebras 
(example~\ref{ex:angelic}). 
The most typical use of relations is for describing termination 
properties and this is how they are used in \cite{c:99, c:7, c:93, c:25, c:18}. 
One introduces a pair of relations: one for defining the 
input-output relation for the terminating computations, and one 
for characterizing the inputs which may (will) lead to divergence. 

At the level of specifications, 
\cite{c:121, c:64, c:21, c:18} pointed in the direction of the relational 
structures by describing non\-deterministic operations by means of 
{\em characteristic predicates}. 
But the relations are used as auxiliary definitions of the 
semantics and are not fully integrated into the formalism of the 
specification language. None of the above works developed a 
relational specification language. An exception is the work from \cite{c:1, c:55, c:123} 
which attempts to develop a theory of data types based on the 
notion of a relation instead of a function. 
The relational language leads to concise, albeit hard to read, 
specifications and gives powerful support in performing calculations. 
Since nondeterminism is implicit in the notion of a relation  --  
functions being just a special case of relations  --   the 
relational approach offers a uniform treatment of deterministic and 
nondeterministic operations. 

\subsection{Homomorphisms}
Homomorphisms for multialgebras 
were defined already in \cite{c:101,c:102}, and then in \cite{c:45, c:53, c:59, c:64, c:93}. 

Recall that a homomorphism $\phi$ between (deterministic) algebras $A$ 
and $B$ is a family of mappings $\phi_{S}:S^{A}\into S^{B}$, for each 
$S\in\Sorts$ such that the following diagram commutes
\[ 
\diagramcompileto{00hom}
S_1^A\times\ldots\times S_n^A \rrto^<<<<<<<<<<{f^A} \dto<-6ex>_{\phi_{{S_1}}} 
      \dto<5ex>_{\phi_{{S_n}}} & & S^A \dto^{\phi_S} \\
S_1^B\times\ldots\times S_n^B \rrto^<<<<<<<<<<{f^B} &  & S^B
\enddiagram
\]

\noindent
i.e., \begin{tabular}[t]{l@{\ :\ }l}
1. for each constant $c:\into S$ & $\phi_{S}(c^{A}) = c^{B}$,  and \\[.5ex]
2. for each function $f:S^{n}\into S$ & $\phi_{S}(f^{A}(x_{1}...x_n)) = 
f^{B}(\phi_{S_{1}}(x_{1})...\phi_{S_{n}}(x_n))$, for all $x_{i}\in S_{i}^{A}$ \\[1ex]
\end{tabular}

\noindent
The transition to nondeterministic structures 
again introduces several possibilities of generalization. They are 
only loosely related to the choice of interpretation of the 
operations. One general remark applies to all of them: Since $f$
is set-valued the result of following the leftmost path in the 
diagram gives a set $f^{B}(\phi(a_1)...\phi(a_n))$. Similarly, 
$f^{A}(a_1...a_n)$ 
 is a set and hence the result of applying $\phi$ to it (all its members) 
will give a set. The two basic possibilities are therefore: 
\begin{eqnarray}
{\rm tight\ homomorphism}:\ \ \phi(f^{A}(a_1...a_n)) & = &
f^{B}(\phi(a_1)...\phi(a_n)) \label{eq:tight} 
\\ 
{\rm loose\ homomorphism}:\ \ \phi(f^{A}(a_1...a_n)) & 
\subseteq &  f^{B}(\phi(a_1)...\phi(a_n)) \label{eq:loose} 
\end{eqnarray}
Any of these two conditions may 
replace the homomorphism condition 1.-2.\footnote{There is also the 
third possibility: {\em closed} homomorphism reverses the inclusion 
from~\refp{eq:loose}. 
But they are less frequent and we do not consider them 
here.} Loose homomorphisms 
correspond to nonincreasing nondeterminism in the pre-image. Notice 
that this does not preclude the cardinality of the set 
$\Car{f^{A}(a_1...a_n)}$
being greater than that of $\Car{f^{A}(\phi(a_1)...\phi(a_n))}$. 
Then some values produced by $f^{A}(a_1...a_n)$
 must be equivalent under $\phi$. Loose homomorphisms (or their 
equivalents) are often used as the implementation criteria since it 
is generally accepted that one should allow deterministic (less 
nondeterministic) implementations of nondeterministic data types
\cite{c:121, c:64, c:94, c:53, c:132}.

Both 
kinds of homomorphisms are used in the literature, though often under 
different names. The vocabulary becomes even more confused since many 
authors introduce the partiality considerations into the definitions 
\cite{c:18, c:21, c:59}. (See \cite{c:21, c:93, c:94} for more detailed 
and idiosyncratic notions.)

\para{Element homomorphisms: $\phi: A\into B$} 
This is the most common way of 
defining homomorphisms in a nondeterministic context, and we will 
denote it by $\EHom$.
Here the basic entities are individuals and homomorphisms send 
individuals to
 individuals. If multialgebras or power algebras are involved one 
still may use this notion of homomorphism since pointwise extension 
then defines the mapping between the corresponding power-sets. In 
either case the homomorphism condition will be modified 
to~\refp{eq:tight} or \refp{eq:loose}.

\para{Multihomomorphisms: $\phi : A\into\PSet(B)$} 
In \cite{c:58, c:59} the element homomorphisms are generalized to the set-valued
ones. There is at least one advantage to be gained from this. In the
deterministic case the initial structure for a given signature
$\Sigma$ is the collection of all words, $\GTerms$. The interpretation
in a structure $A$ is given by the {\em unique} homomorphism
$\uni:\GTerms\into A$.  In the nondeterministic case we may want to
interpret some terms as sets. The notion of tight multihomomorphisms
makes such an interpretation a unique homomorphism whereas element
homomorphisms do not.
\begin{Example}\label{ex:noinit}
Let $\Sigma=(\{S\},\{c:\into S\})$. The $\Sigma$-word multistructure
$\GTerms$ will consist of one element sort $S^{\GTerms}=\{\und c\}$ with
$c^{\GTerms} = \{\und c\}$. Let $A$ be a $\Sigma$-structure with
$S^A=\{1,2\}$ and $c^A=\{1,2\}$. There is no tight $\EHom$
$\GTerms\into A$ while there are two loose ones.  
 But there is a unique
tight multihomomorphism $\uni:\GTerms\into A$, given by $\uni(\und c)=\{1,2\}$.
\end{Example}
Similarly, there are several (three, or if we allow homomorphisms to
map elements on empty set, then four) loose multihomomorphisms.  Thus,
only with tight multihomorphisms will $\GTerms$ be an initial
$\Sigma$-structure. But this result hardly generalizes to model
classes of specifications \cite{c:59, c:128}.

$\uni$ may happen to be a tight homomorphism in $\EHom$ if we do not
explicitly distinguish individuals from sets. Then, if a structure $A$
happens to be a power algebra, the mapping $\uni:\GTerms\into A$ will actually
send terms to sets since here $A$ is the power-set of some set.
(If we take $A$ from the above example to have the carrier
$\PSet(\{1,2\})$, then the unique tight $\EHom$ will give $\uni(\und c)=\{1,2\}.$)
 But
then sets, which are the interpretations of terms, cannot be
identified with the {\em result} sets since the distinction between
individuals and sets disappears (sets are individuals in a power set).

Admitting multihomomorphisms, one also has to decide whether a point
$a\in A$ may be mapped onto the empty set or not. The former would
introduce ``partial homomorphisms'' -- $\phi(a)=\es$ corresponds to 
an $\EHom$ which is undefined on $a$. Although used in the context
of partial algebras, we have not encountered extensive use of such a
concept with nondeterministic algebras (e.g. \cite{c:21, c:93}).

Multihomomorphisms will be denoted by $\MHom$.

\para{Power homomorphisms: $\phi:\PSet(A)\into\PSet(B)$} 
This notion may lead to the 
peculiarities reminiscent of those of unrestricted 
(to $\subseteq$-monotonic) 
functions in power algebras. The intention behind 
the definition of a homomorphism is to make 
the mappings from individuals to individuals and from sets to sets 
``compatible'', even if the specification language 
is insufficient for dealing with this distinction.  Both $\EHom$ and 
$\MHom$ ensure such ``compatibility''  
 --   mapping from a power-set is obtained by pointwise extension 
of the mapping from individuals.

\begin{Example}\label{ex:212} 
Suppose that 
$\Sigma$ contains only two constants of sort $S$, $0$ and $1$. Let 
$A$ and $B$ be the following power algebras: 
\[ \begin{array}{l@{\ \ \ \ \ \ \ \ \ }l}
\Car A = \PSet(\{\und 0, \und a, \und b\}) & \Car B = \PSet(\{\und 0, 
\und 1\}) \\[.5ex]
0^{A}=\{\und 0\},\ \ 1^{A}=\{\und a, \und b\} & 
  0^{B}=\{\und 0\},\ \ 1^{B}=\{\und 1\} 
  \end{array}
\]
\noindent
A power homomorphism  $\phi:A\into B$ must send 
$\{\und 0\}$ onto $\{\und 0\}$ and $\{\und a,\und b\}$ onto $\{\und 
1\}$.  The rest is arbitrary so, for instance, 
we may have $\phi(\{\und a\}) = \phi(\{\und b\}) = \{\und 0\}$. 
\end{Example}

This does not look very plausible. 
Again, as in the case of the power functions, it helps a lot if we 
insist that homomorphisms be $\subseteq$-monotonic. 
But the point is how such a requirement is expressed. If 
we just restrict the legal morphisms to those which are $\subseteq$-monotonic 
then we will exclude mappings which, like the one 
above, preserve the $\Sigma$-structure and satisfy the compatibility condition defining 
homomorphisms.

It can be seen from the example that the trouble arises from the fact 
that we do not have a syntactic operation which would correspond to 
the semantic operation of set construction. Choice is not really such 
a constructor. If interpreted as set union, it would enable us to construct 
only the set $\{\und 0, \und a, \und b\}$ in $A$, but not, for instance 
$\{\und a\}$. Thus, 
instead of extending the gap between syntax and semantics we might 
consider extending the specification language with an appropriate 
operation (predicate) such that the 
homomorphism condition wrt. to this operation would imply 
$\subseteq$-monotonicity. Several works \cite{c:77, c:59, c:87, c:91} introduce such an 
operation. If, in addition, the language contains a predicate 
expressing that something is an individual \cite{c:91} then homomorphisms 
are again determined by the images of singletons. This leads to
 the same class of mappings as $\EHom$ since strict, additive mappings 
from $\PSet(A)$ to $\PSet(B)$ which, in addition, preserve singletons 
are isomorphic to the mappings from $A$ to $B$:
\begin{Claim} 
$[A\into B]\iso [\PSet(A)\into_{\uplus,1}\PSet(B)]$.
\end{Claim} 
See also \cite{c:102, c:106} for the 
results concerning the relationship between various forms of mappings 
between power-sets. Extending the notational analogy with the models 
we will denote the power homomorphisms by $\PHom$.


\subsection{Equivalencies.}\label{sub:equiv}
Although it might seem natural that 
``='' should be interpreted in power-set structures as set equality 
(since the operations return sets) it is not obvious that the natural 
choice is the better.

\para{Element equality} 
First of all, the sets returned by 
the operations represent {\em possible} results. But each particular 
application of every operation will return only {\em one unique} 
result. Thus, for instance, if $\{s\}=\{0,1\}$ and $\{t\}=\{0,1\}$
 it may very well happen that one 
application of $s$ returns 0 while an application of $t$ 
returns 1. One may require that two equal terms {\em always} return 
the same results. This {\em element equality}
 reflects a strict view of observability  --   two terms are equal 
only if they are {\em necessarily} equal, i.e.,
 they are deterministic and alway return identical results. This 
notion of equality corresponds to the function oriented model and, 
like that model itself, has not received much attention in the 
literature (except for \cite{c:127, c:133, c:130}). Its apparent oddity 
lies in the fact that, since a nondeterministic operation may return 
different results at different invocations, it is not even an 
equivalence relation. This reflects the lack of referential 
transparency which is intrinsic to nondeterministic operators.

\para{Set equality} 
Slight variations of set equality have been applied by many
authors: under the name of {\em ideal congruence} in \cite{c:102}, {\em
extraction} equivalence in \cite{c:53, c:121}, {\em observational} equivalence
in \cite{c:64}. Variations concern mainly whether one uses plain set equality
or whether the relation is defined in the context of observability. In
the latter case there are hidden and visible sorts, and terms {$s$ and
$t$ are extraction equivalent iff for all values of $x_i$, sets
returned by all visible contexts $C[\_,x_i]$ when applied to $s$ and
$t$ are equal.\footnote{We do not focus on the distinction between
visible and hidden sorts which, though formally important, would only
add unecessary details to the presentation.
Also, the
contexts $C[\_,x_i]$ contain not only a ``hole'' `$\_$', but admit
additional ``probing'' variables $x_i$. This is certainly another
important matter which varies from one definition to another. We chose
this formulation from \cite{c:53} for the sake of the following theorem.
(A variation of
extraction equivalence, ``{\em inseparability},'' repeats the definition~\refp{eq:214} with
the additional requirement of $x_i$ being observable.)}
Thus an equivalence relation $E$ is an {\em extraction} equivalence iff
\eq{\forall (s,t)\in E\ \forall C[\_,x_i]\in\XTerms X\ \forall x_i\ \forall a\in 
\{C[s,x_i]\}\ \exists b\in\{C[t,x_i]\} : (a,b)\in E}\label{eq:214}
The following result is then reported in \cite{c:53, c:102}.
\begin{Theorem}  
Let $SP$ be a specification, $M$ a multimodel, $E$ 
an extraction equivalence on $M$, and $[x]$ the $E$-equivalence class 
of $x\in M$. Then $M/E$ is a multimodel, where
\begin{itemize}  
\item the carrier of $M/E$ is the set of $E$-equivalence classes 
$\{ [x]:x\in\Car M \}$
\item $f^{M/E}([x_1],...,[x_n]) = \bigcup_{y_{i}\in[x_{i}]} \{ [a]:a\in f^{M}(y_1,...,y_n) \}$.
\end{itemize}
\end{Theorem}

\noindent
There is, of course, an implicit assumption about the form of the
axioms in $SP$. In \cite{c:102} $SP$ is just a signature, but if axioms are
also present, as in \cite{c:53}, then the theorem does not hold in full
generality. For the deterministic models, it is shown in \cite{c:74}, that
the model class of $SP$ is closed under homomorphic images iff all the
axioms of $SP$ are positive formulae. It is easy to construct an
example with inequality among the axioms that will show that for a
given multimodel $M$, $M/E$ is not necessarily a multimodel.  (Since
usual deterministic algebras are special case of multialgebras and
congruences are extraction equivalences, they may be used to provide such
a counterexample.)  It is not therefore unreasonable to expect that
the result from \cite{c:74} will generalize to multimodels.

The importance of this nice counterpart of the analogous result for 
the deterministic equational classes is further diminished by the 
fact that one is still left with the problem of constructing a 
multimodel (the initial one?) from which one could start taking quotients. 
 
\para{Consistency relation} 
Equality interpreted as set 
equality means that two terms are equal if they {\em possibly 
can} return the same 
results. It does not, however, guarantee that they will. In terms of 
an arbitrary actual observation it does not guarantee anything. 
Following this line of thought of ``the possible,''
 one arrives at the notion of the equality as the sheer prospect that 
two terms may conceivably happen to return the same result.

\begin{Example}  
Suppose we have a 
specification with two sorts $V$ (visible) and $H$ (hidden), and the 
operations binary choice $\ch: H\times H\into H$, and $g:H\into V$. 
Let $A$ be a multistructure where 
\[\begin{array}{l@{\ \ }l@{\ \ }l@{\ \ }l}
H^{A}=\{\und a, \und b, \und c\} & V^{A}=\{\und 0, \und 1, \und 2\} \\[.5ex]
x\ch^{A}y=\{x,y\} & g^{A}(\und a) = \{\und 0\} & g^{A}(\und b) = \{\und 1\}
   & g^{A}(\und c) = \{\und 2\}
   \end{array}
\]
We then have $g(\und a\ch\und b)^{A} = \{\und 0,\und 1\} \not= \{\und 
0,\und 2\} = g(\und a\ch\und c)^{A}$.

If we stick to the strict model of observations then each observation 
involves only one unique result. Now, unless we impose some fairness 
conditions on $\ch$, it is free to display any degree of nondeterminism. 
We have no guarantee that the choice operator will produce all possible 
results. Since $\{\und 0,\und 1\}\cap\{\und 0,\und 2\}\not=\es$, 
we cannot be sure that both $g(\und a\ch\und b)^{A}$ and $g(\und a\ch\und c)^{A}$  
won't consistently produce the same result.
\end{Example}
Thus, under this interpretation, $s=t$ if $\res s \cap \res t \not=\es$. 
This relation is 
called {\em inseparability} in \cite{c:53}: $s$ and $t$
 are inseparable if both are capable of returning the same result, 
i.e., if there {\em is a possibility} that one may be unable to see 
the difference between them. This is not an equivalence relation. (It 
is not transitive, e.g., $\res s=\{0,1\}, \res t=\{1,2\}, \res p 
=\{2,3\}$.) The appropriate 
generalization requires the following definition:\footnote{Notice that here we have
ground contexts with a ``hole'' `$\_$', but with no additional variables $x_i$.}
$E$ is a {\em consistent} relation iff
\eq{\forall (s,t)\in E\ \forall C[\_]\in\XTerms\  \exists a\in 
\{C[s]\}\ \exists b\in\{C[t]\} : (a,b)\in E}
\label{eq:cons} 

Two terms are {\em consistent} \cite{c:64, c:53} if they belong to some 
consistent relation. (In particular, 
suppose that $t$ and $s$ are ground terms and $\res t, \res s$ 
are their set interpretations in a given structure $A$. 
If $E$ on the individuals from $A$ is equality and we let 
$[t]$ denote the class of terms 
equivalent to $t$ with respect to the relation $E$, then 
$\bigcap_{s\in[t]}\res s$ must be non-empty.
E.g., $s$, $t$ and $p$ above cannot all 
belong to the same $E$-equivalence class because $\res s \cap \res 
p =\es$.) 

Consistent relations
 generalize the notion of congruence. A congruence relation is 
consistent and a consistent relation on a deterministic structure is 
a congruence. The same applies also to the extraction equivalencies. 
This is a frequently occurring phenomenon that different generalizations 
of deterministic concepts to the nondeterministic 
context all reduce to the same definition when restricted again to 
the deterministic situations.

 Obviously, extraction equivalence implies 
consistency, and in fact, consistency is maximal 
among the considered interpretations of equality in the sense that it 
will identify every pair of terms which possibly (consistently) can 
be identified. Thus it corresponds to the maximal congruence for a 
deterministic structure and, in analogy with the latter, 
characterizes the terminal multimodels (see section~\ref{se:terminal}, theorem~\ref{th:41}). 

\cite{c:53} contains more detailed and intricate notions of equivalences and 
relations between them. We can also refer to the interesting work in 
\cite{c:93, c:94, c:95} for a more ``realistic'' study of the nondeterministic 
equivalence where observations are defined relative to a given 
programming language.


\section{Initial models and specification languages}\label{se:init}
The success of the initial semantics for deterministic equational 
specification motivated many attempts at 
generalizing it to the situations where also nondeterministic 
operations are specified equationally. 
Below 
we review some of these attempts and arrive at the conclusion that purely 
equational specification of 
nondeterminism is insufficient for ensuring the existence of an initial model. 
Some more refined tools -- at 
the syntactic as well as semantic level -- are needed.

Consider an equational specification $SP$ which is supposed to be 
given a power algebra semantics. As 
we have observed, power algebras are deterministic structures, 
and furthermore, any standard model of $SP$ 
may be considered a power model by identifying all elements with 1-element 
sets and extending the 
operations pointwise. Thus, any equational specification will have 
a power model which is initial in the 
category $(\PMod,\PHom)$. But what is missing in such a model is nondeterminism. 
The crucial thing for the 
semantics of nondeterminism is the distinction between the 
individuals and the sets of individuals which 
gets completely lost in $\PMod$ and $\PHom$. In fact, an initial power model need 
not consist of 1-element 
sets. Any sets will do, since distinct sets are just distinct 
elements in $\PMod$ and $\PHom$ map sets to sets 
without considering their elements. 

The semantic distinction may be introduced in various ways, for instance, 
by taking the category $(\PMod,\MHom)$ 
or $(\PMod,\EHom)$. In the former case, the same (deterministic) model as in 
$(\PMod,\PHom)$ will be initial  
(provided the $\MHom$ are tight), so things do not really get much more 
exciting. In the latter case, the 
deterministic power term structure will not be initial any more, since 
there will be several element 
homomorphisms from a model interpreting every term as a 
1-element set to a model where some terms 
are interpreted as sets with more than one element (example~\ref{ex:noinit}).
What is needed is a closer relationship between the intuitive meaning of the power-set structures (i.e., 
sets as the result sets of the operations) and the syntactic means of specifying the relations reflected in such 
structures.  

\subsection{Choice as a primitive -- set union}\label{sub:primitive}
A ``minimalistic'' approach \cite{c:63, c:77} admits two primitives in the specification language: 
equality, which is 
interpreted as set equality, and binary choice which is specified by the join axioms:
\[
\begin{array}{r@{\ \ \ \ \ }r@{\ =\ }l@{\ \ \ \ }l}
{\rm J:} & x\ch y & y\ch x & {\rm (JC)} \\
 & x\ch(y\ch z) & (x\ch y)\ch z & {\rm (JA)} \\
 & x\ch x & x & {\rm (JI)}
 \end{array}
 \]
Sometimes one also introduces a bottom element -- the empty set 
\cite{c:50} -- and 
postulates distributivity of $\ch$ \cite{c:63, c:91}:
\[
\begin{array}{r@{\ \ \ \ \ }r@{\ =\ }l@{\ \ \ \ }l}
{\rm J1:} & x\ch \perp & x & {\rm (JE)} \\
 & f(\ldots,x\ch y,\ldots) & f(\ldots,x,\ldots)\ch f(\ldots,y,\ldots) & 
 {\rm (JD)} 
  \end{array}
\] Notice that the last axiom ensures singular semantics.  So far, we have 
not done anything new -- $\ch$ is just a new deterministic operation 
specified equationally.  To make it into a {\em choice\/} one may attempt 
to require that $\ch$ is to be interpreted as set union.  This, however, 
goes awry very quickly:

\begin{Example}\label{ex:union} 
The specification with three constants $0,1,2$ and the axiom $0\ch 1 = 
0\ch (1\ch 2)$ has no initial model. For, 
constants must be interpreted as singletons $\{\und 0\},\{\und 
1\},\{\und 2\}$,\footnote{Actually, this depends on the power-set 
structure and homomorphisms one is working with. $\PMod$ would give 
the possibility of interpreting them as arbitrary sets. They have to 
be different sets, though, so the problem would persist anyway.} and $\ch$ is set union, so $\uni(0\ch 1) = 
\{\und 0,\und 1\}$ and 
$\uni(0\ch(1\ch 2)) = \{\und 0,\und 1,\und 2\}$.  In order to make
these two sets equal we have to identify $\und 2$ with $\und 0$ or
$\und 1$.  Either choice leads to the situation where there is no
homomorphism to the model obtained by realizing the other
choice. Also, since choice is set union we cannot take $\uni(0\ch 1)$
to be the set $\{\und 0,\und 1,\und 2\}$.
\end{Example}

The problem arises from the fact that one has decided in advance what
the meaning of $\ch$ should be. Since it {\em is} set union, there is
no other way to make the sets $\uni(0\ch 1)$ and $\uni(0\ch (1\ch 2))$
equal than by identifying $\und 2$ with $\und 1$ or $\und 0$. Taking
the quotient of the term structure or interpreting $0\ch 1$ as the set
$\{\und 0,\und 1,\und 2\}$ are excluded.  Thus axioms affecting the
semantics of choice may introduce inconsistency (albeit not a logical
one) with this pre-defined meaning.  The axioms J1 are given in
\cite{c:63} without requiring the interpretation of $\ch$ as set
union. Then, of course, all equational specifications will have
initial models, but this again is at the price of losing control over
the distinction between deterministic and nondeterministic operations.
Nevertheless, conditions are given (in terms of the associated
rewriting systems) under which initial models of such specifications
are isomorphic to the expected multimodels with $\ch$ interpreted as
set union. The conditions (left-linearity and $\ch$-freeness, see
section~\ref{se:rew}) amount to forbidding situations like the one
from the example -- $\ch$-freeness, for instance, disallows equating
two terms which both contain occurrences of $\ch$.

The problem in example~\ref{ex:union} actually has two parts: One is that choice obtains some fixed 
semantics. Set union is perhaps not the best one and we will see in a moment other  possibilities. The 
other is that the specification language does not provide sufficiently flexible means for introducing new, 
nondeterministic operations by reference to this primitive one. Equations are symmetric and affect equally 
both sides. Introduction of a new operation, $f$, defined by $f=0\ch 1$, 
and $f=0\ch (1\ch 2)$ would lead to the same 
problem. Thus each new equation is a potential source of a conflict. 

It turns out that an increase in the expressive power of the specification language is required. Some 
refinement of the equational language is needed for ensuring that choice will be a nondeterministic 
operation if this is not secured by some predefined semantics. A more flexible language is needed to 
distinguish between the equivalence of two terms and the fact that one denotes only a (more 
deterministic) possible result of the other.

\subsection{Inclusion}\label{sub:inclusion}
Since ``='' is interpreted as set equality it shouldn't do much harm
if we instead made use of set inclusion as the primitive relation
between terms \cite{c:59, c:58, c:127, c:133, c:130}.  Hu{\ss}mann
supplies a very constructive generalization in \cite{c:59, c:58} where
he introduces appropriate rewriting techniques. Inclusion is the only
primitive operation in the language of \cite{c:59,
c:58}. Specifications are sets of inclusion rules (we shall keep
``$\subseteq$'' for denoting set inclusion in the structures and use
``$\Incl$'' for the corresponding syntactic relation):

\begin{Example}\label{ex:unionb}  
Choice is no longer a primitive operation, so we specify it explicitly:\\[1ex]
\hspace*{2em}
	$1)\ \ \  0 \Incl \ch.\{0,1\}, \ \ \ 1 \Incl \ch.\{0,1\}$ \\[.5ex]
\hspace*{2em}
	$2) \ \ \ 0 \Incl \ch.\{0,1,2\},\ \ \  1 \Incl \ch.\{0,1,2\},\ \ \   2 \Incl 
	\ch.\{0,1,2\}$ \\[1ex]
The problematic axiom becomes now:\\[1ex]
\hspace*{2em}	$3)\ \ \  \ch.\{0,1\} \seteq  \ch.\{0,1,2\} $ \\[1ex]
(writing $\seteq$ for two inclusions)
The initial model is given by the following interpretation\\[1ex]
\hspace*{2em}
	$4)\ \ \  \uni(c) =\{\und c\}$\ \ \ \  for $ c=0,1,2$ \\[.5ex]
\hspace*{2em}
	$5)\ \ \ \uni(\ch.\{0,1\}) = \uni(\ch.\{0,1,2\}) = \{\und 0,\und 1,\und 2\}$
\end{Example}

Since we have inclusions instead of equality in 1) the (initial) interpretation 
of $\ch.\{0,1\}$ can be expanded if 
necessary -- here it contains $\und 2$ besides $\und 1$ and $\und 2$. 
Choice is no longer primitive -- the semantics of sets is built 
into the semantics of $\Incl$. In the initial (term) model, any term $t$ is 
interpreted as the set of $[s]$ such that $s\Incl t$, 
where $[s]$ is the equivalence class of $s$, i.e., the set of all $p$ such 
that $s\seteq p$.

However, to ensure the existence of the initial models some assumptions 
about the specification must 
be made \cite{c:59, c:58}. One is that the specification has to possess a {\em deterministic basis}, 
i.e., a set of terms 
which are interpreted as singletons, and such that every term can be reduced to at least one deterministic 
term (DET-completeness). To express this a predicate $DET$ is introduced 
into the language, where $DET(t)$ 
is valid if the term $t$ is deterministic. 
Another assumption (DET-additivity) implies that arguments in the right hand sides of inclusions 
must be deterministic. For instance, instead of $0\Incl f(1\ch 2)$ we must 
write $0\Incl f(1)$ and $0\Incl f(2)$. Under these 
assumptions, every specification has a (loosely) initial model in 
$(\MMod,\MHom)$ which can be constructed 
as in the above example. (These conditions are further discussed in section 7.)

\subsection{Partial orders}\label{sub:PO} 
Instead of sticking to the set interpretation one may generalize 
the fact that the set union (choice) is a join 
operator. That is, instead of set union we can speak about join; instead 
of inclusion -- about a partial order. 
The first work exploring these ideas in an algebraic framework is \cite{c:77}. 
Given the axioms J (from~\ref{sub:primitive}) 
and a language with $=$ and $\ch$, one can define a structure on the models reflecting the intended 
nondeterministic interpretation. For each sort in the signature 
$\Sigma$, the {\em result partial order} on the word 
structure $\GTerms$, $\Incl$, is defined \cite{c:77, c:49}:
\[
\begin{array}{r@{\ \ \ \ \ }l@{\ \ }l}\label{def:R}
{\rm R:} & s \Incl t\ \ \ {\rm iff\ } & 1.\ s\syeq t\ \  {\rm\ or} \\
 & & 2.\ t \syeq s\ch s_{1}\ \ {\rm\ or} \\
 & & 3.\ s\syeq f(p_{1},\ldots,p_{n}),\ t\syeq 
 f(r_{1},\ldots,r_{n}),\ {\rm and\ for\ all\ } i : p_{i}\Incl r_{i}
 \end{array}
 \]
This definition amounts to the standard definition of a partial order on a lattice extended with the 
monotonicity axiom 3. which ensures that an increase in nondeterminism of the arguments never 
decreases the nondeterminism of the result. Note that the singularity axiom JD does not follow from J+R. 
We only have that R3 implies $f(...,x,...) \ch f(...,y,...) \Incl 
f(...,x\ch y,...)$, reflecting our intuition that whatever can 
be produced under singular semantics can also be produced under the plural one.
Equational specifications with $\ch$ (and the axioms J) are just classical equational specifications and 
hence always possess initial models. These models are essentially deterministic and nondeterminism is 
{\em encoded} as the additional structure $\Incl$ implied by the occurrences 
of $\ch$. However, $\Incl$ is not a part of the specification language. 

\begin{Example}\label{ex:collapse} 
Let us suppose that we want to add a new operation $f$ to the specification (J) with the following 
axioms:
\[ \begin{array}{l@{\ \ }r@{\ =\ }l}
	1) & f(x_{1},x_{2},x_{3}) &  x_{1}\ch x_{2}\ch x_{3} \\
	2) & f(0,1,2)  &  f(0,0,1)
\end{array}
\]
We will obtain an initial model where $0\ch 1 = 0\ch 1\ch 2$. This does not cause the problems of 
example~\ref{ex:union}
since we now have a deterministic structure and merely take quotients of such structures. 
However, as a result we will obtain that $2 \Incl 0\ch 1$ holds, which is perhaps not quite what we had in 
mind.
\end{Example}

 It may be slightly surprising that defining a new operation has such
consequences for the original structure. After all, writing 1) and 2)
we might be interested not in changing the semantics of choice, but
only in defining a new nondeterministic operation which behaves a
little differently in some cases -- for instance, so that it never
returns some ``forbidden'' values. This illustrates the failure of
this ``deterministic'' approach to reflect, in the general case, the
intended meaning of nondeterministic choice as set union. The
specification from example~\ref{ex:collapse} does not conform to the
restrictions from \cite{c:63} mentioned at the end of
subsection~\ref{sub:primitive} which make models of specifications
with $=$ and $\ch$ isomorphic to the intended models where $\ch$ is
interpreted as set union.  The collapse of the original ordering
results here from the exclusive use of equations. The approach from
subsection~\ref{sub:inclusion} can easily accommodate such a
situation.  Using inclusions instead of equality and making $\ch$ a
defined operation allows one to specify the nondeterministic
operations directly.

\begin{Example}\label{ex:incl} 
The corresponding specification would be:
\[ \begin{array}{r@{\ \ }rcl@{\ \ }l}
	1) & x_{i} & \Incl & f(x_{1},x_{2},x_{3}) & 	{\rm for\ } i=1,2,3\\
	2) & f(0,1,2) & \seteq & f(0,0,1) 	
\end{array}
\]
The initial interpretation will assign the set $\{\und 0,\und 1,\und 2\}$ to both 
$f(0,1,2)$ and $f(0,0,1)$. This does not 
affect semantics of other operations, like $\ch$, which are specified independently. 
\end{Example}
 
The resulting partial order $\Incl$ is introduced in \cite{c:77} in addition to the continuous structure on the models 
needed for finding the solutions of recursive systems of equations. We devote section 5 to this topic and 
will continue the discussion of the present work there. At this point we may only remark that as the 
consequence of using continuous algebras the model class is no longer closed under substructures and 
quotients. Thus initial models can not be constructed simply as quotients of the word structure.

\subsection{Lattices and unified algebras}\label{sub:unified}
The approach discussed above introduced axioms for the join operation and 
defined (implicitly) the corresponding partial order.  Examples~\ref 
{ex:collapse} and \ref{ex:incl} indicated that it might be advantageous to 
reflect the semantically defined partial order in the specification 
language.  This leads us directly to lattice structures.  In a very general 
form, they have been proposed as the theoretical foundation of data types 
in \cite{c:115, c:116}.  In \cite{c:6} lattices are used to define a 
specification language enabling the construction of the weakest predicate 
transformers for commands which include angelic and demonic nondeterminism, 
and in \cite{c:1} a relational approach to data types uses lattices as the 
basis of the specification language and relational calculus.  Here we will 
consider a very elegant construction of unified algebras introduced by 
Mosses in \cite{c:92, c:91}.  Unified algebras combine the advantages of 
several approaches described so far, adding new, interesting features.

Every unified signature $\Sigma$ contains the subsignature $\Omega$ with the operations 
$\{\nothing, \_|\_, \_\&\_\}$ and 
predicates $\{\_=\_, \_\leq\_, \_:\_\}$. 
For the sake of notational compatibility with the rest of this exposition we will 
use the symbols $\{\perp, \_\ch\_, \_\meet\_\}$ and $\{ \_=\_, 
\_\Incl\_, \_:\_\}$. 
Formulae of the specifications are (universal) Horn 
clauses. A unified $\Sigma$-algebra $A$ is a structure (with one sort) such that:
\begin{itemize}\MyLPar
\item	$\Car A$ is a distributive lattice with $\ch^{A}$ as join, 
$\meet^{A}$\ as meet, and $\perp^{A}$ as bottom.
\item	There is a distinguished set $E\subseteq\Car A$ -- the individuals 
of $A$.
\item	$=^{A}$ is the identity on the elements of the lattice (not only on the individuals).
\item	$\Incl^{A}$ is the partial order of the lattice, i.e., 
$x\Incl^{A}y$ iff $x\ch^{A} y =^{A} y$.
\item	For every $f\in\Sigma$, $f^{A}$ is monotonic wrt. $\Incl$.
\item	$x :^{A} y$ holds iff $x\in E^{A}$ and $x\Incl^{A}y$.
\end{itemize}
``Unified'' refers to the fact that there is only one syntactic sort, and no syntactic distinction is made 
between sorts and individuals. Sorts in the sense of classical algebra, as well as individuals, are elements of 
the lattice. Also sorts and nondeterminism are treated in a unified way. The partial order of the lattice 
corresponds to set inclusion; sorts and nondeterministic choice are 
interpreted as joins -- the elements 
``just above'' their members. The set $E$ represents the individuals. The individuals need not be the atoms of 
the lattice, i.e., the elements ``just above'' the bottom, though, typically, 
this will be the case. $\_:\_$ is the 
membership of singletons -- $t:s$ means that $t$ is contained in 
$s$ ($t\Incl s$) and $t$ is an individual. Monotonicity 
with respect to the partial order of the lattice allows the extention of the definitions of the operations on 
individuals to their respective upper bounds (sorts or nondeterministic choices).
The revision of example~\ref{ex:collapse}-\ref{ex:incl} will look as follows:

\begin{Example}\label{ex:unif} 
The richer semantics gives us several possibilities to interpret the problem. 
\[ \begin{array}{r@{\ \ }l}
	1) & x_{i} \Incl f(x_{1},x_{2},x_{3})\ \ \ \   {\rm for\ } i=1,2,3 \\
	2) & f(0,1,2) = f(0,0,1),
	\end{array} \] 
This specification will lead to the initial model where $2$ is a possible result of (lies ``below'') $f(0,0,1).$ 
The alternative
\[ \begin{array}{r@{\ \ }l}
	1') & f(x_{1},x_{2},x_{3}) \Incl \ch.\{x_{1},x_{2},x_{3}\} \\
	2') & f(0,1,2) = \ch.\{0,1\}
\end{array} \]
will ensure that the result set of $f(0,1,2)$ is the join of $0$ and 
$1$ and does not include $2$. All the other 
applications of $f$ will be ``just below'' the corresponding $\ch$, but their only result in the initial model 
will be the bottom element. 
\end{Example}
 
Axioms $1'$)-$2'$) yield a specification which, in the terminology from 
subsection~\ref{sub:inclusion}, is not DET-complete, and hence 
does not have an initial multimodel. This fact is reflected in the initial 
unified algebra by the $\perp$ element 
which corresponds to an unspecified result set of $f(x_{1},x_{2},x_{3})$.
 
Of course, it can still happen that the ordering collapses as it did in 
example~\ref{ex:collapse} (e.g., take 1) and 
$2'$). Although choice is a primitive operation of unified algebras, the specification language gives one the 
ability to avoid (or introduce) such cases at will. 

The ``inclusion'' approach from subsection~\ref{sub:inclusion} can be
subsumed under unified algebras.  Thus $DET(t)$ corresponds to $t:t$
and inclusions to the partial order -- the other way around, $t:s$ is
the same as $t\Incl s \land DET(t)$. The initial unified algebra model
of 1)-3) from example~\ref{ex:unionb} will be essentially the same as
the one presented there (a lattice with individuals $\und 0, \und 1$
and $\und 2$, and the top element $\ch.\{\und 0,\und 1\}=\ch.\{\und
0,\und 1,\und 2\}$). In fact, both will give the same class of models
when interpreted in multialgebras. The analogy can be further
illustrated by the fact that both approaches emphasize the distinction
between individuals and sets and, in fact, treat the distinction in
quite similar ways.
\begin{Example}\label{ex:ind} 
\[ \begin{array}{r@{\ \ \ \ \ }l@{\ \ \ \ \ \ \ \ \ \ }l}
  &	       {\rm Unified\ algebra} &       {\rm  Hu{\ss}mann's\ 
  multialgebra} \\[.5ex]
 & 		 0:0,\ 1:1, 		& DET(0),\ DET(1), \ 0\Incl 
 0\ch 1,\  1\Incl 0\ch 1 \\
	1.  &	  c: 0\ch 1	&		  DET(c),\ c\Incl 0\ch 1 \\
	2.  &	  d=0\ch 1	& 		  d\seteq 0\ch 1
\end{array} \]
In 1.  $c$ is a nondeterministic {\em constant}. In the initial model it is an 
(additional) element below $0\ch 1$, 
and in any model where $0$ and $1$ are the only individuals it will be equal to either of them (to 
which, will vary from model to model). $d$ in 2. is a nondeterministic 
{\em operation} equivalent to $0\ch 1$, 
i.e., it is the same element in the lattice as $0\ch 1$. 
\end{Example}

The distinction between individuals and sets cannot be expressed if
equality is the only primitive of a language. But it should be obvious
that it may be essential to know whether we are speaking about the
result returned by a particular application of a nondeterministic 
operation, or about the set of such results.

In the last example we show a feature of the unified algebras which brings us closer to the explicit 
treatment of the singular vs. plural semantics. The basis for the distinction is the possibility of defining 
functions either by the pointwise extension from their definition on individuals or by direct definitions on 
the non-individual arguments.
\begin{Example} 
Define operation $i\!f(\_,\_,\_)$ (for if\_then\_else\_) and $f:$ \\[1ex]
\hspace*{2em} $	i1)\ \ \   i\!f(\true, x, y)  =  x\ \ \ i\!f(\false,x,y)  =  y$ \\[.5ex]
\hspace*{2em} $	i2)\ \ \   i\!f(z\ch w, x, y)  =  i\!f(z,x,y) \ch  i\!f(w,x,y)$ \\[.5ex]
\hspace*{2em} $	3)\ \ \ \  f(x) = i\!f(x=x, 0, 1)$ \\[1ex]
Then for all values of $x$, $f(x)=0$. In particular $f(0\ch 1)=0$ since the equality $x=x$ holds for all elements 
of the lattice. This is the result required by the singular semantics of 
the argument in $f(x)$. 
Let us define a new equality predicate $\approx$: \\[1ex]
\hspace*{2em} $	e1)\ \ \ x:x \impl (x\approx x) = \true	$ \\[.5ex]
\hspace*{2em} $	e2)\ \ \ (0\approx 1) = \false $ \\[.5ex]
\hspace*{2em} $	e3)\ \ \ (x\approx y) \Incl \true \ch \false$ \\[1ex]
Monotonicity of the operations and axiom e3) give then 
$ (0\ch 1 \approx 0) = \true\ch \false$ and $(0\ch 1 
\approx 1) = \true \ch \false$, 
and hence \\[1ex] \hspace*{2em}
$   *)\ \ \ (0\ch 1 \approx 0\ch 1) = \true\ch \false.$  \\[1ex]
Observe that the antecedent in e1) forces $x\approx x$ to be true only when $x$ is an individual. Now change 3) to \\[1ex]
\hspace*{2em}
$	3')\ \ f'(x) = i\!f(x\approx x, 0, 1) $ \\[1ex]
Because of $*)$, i2) implies that 
$f'(0\ch 1) = 0\ch 1$ reflecting the plural meaning of the argument  in $f'(x)$.
\end{Example}
 
This example illustrates the power of unified algebras in the
treatment of nondeterminism which is unmatched by any other approach
we have discussed. On the one hand this feature is related to the
ability to distinguish between individuals and sets -- but now with
respect to variables. In \cite{c:58, c:59} the distinction was
applicable only to terms which were not single variables. For a given
non-variable term (say, $f(x)$) one could write $DET(f(x))$ (to make
$f(x)$ deterministic) or not (to allow $f(x)$ to include several
results), but for variables the axiom $DET(x)$ was always a given. On
the other hand, this is a consequence of the fact that the variables
in unified algebras refer to arbitrary elements of the lattice, and
these elements may represent individuals as well as
sets. Consequently, operations are in general interpreted as in power
models, i.e., map sets to sets. Singular semantics is obtained 
by taking the pointwise extension of the operations
defined on the individuals.

The main advantage of unified algebras is that specifications using at most Horn clauses always have 
initial models (and the operations from $\Omega$ can be specified by Horn formulae). Other advantages follow 
from the general properties of institutions \cite{c:41, c:112, c:122} in which unified algebras are defined. In 
particular, the institution of unified algebras is liberal so that one can impose (under a slightly modified 
definition of the forgetful functor) various data constraints, such as 
the fact that $\true\not= \false$.

\subsection{The price of initiality} 
We have seen that multialgebraic semantics does not, in general, admit initial models and that one has to 
introduce some partial order (lattice) structures to guarantee the existence of such models. We end this 
section by observing some disadvantages of the initial semantics in modeling nondeterminism \cite{c:128}.

Partial orders provide simpler mathematical structures than multialgebras. However, this is a 
consequence of the fact that the distinction between individuals and 
sets -- which is the underlying 
intuition of the distinction between deterministic and nondeterministic 
operations -- gets blurred. 
Consequently, the partial order models sometimes fail to correspond to any set based structure which 
would express the intended meaning of a nondeterministic specification. 

Taking choice as the primitive (join) may lead to the uninteded collapse of the ordering if one is not 
sufficiently careful in writing the axioms. Furthermore, the minimal elements of a partial order need not 
correspond to the actual individuals. A specification with two nondeterministic constants $a$ and $b$, and the 
axiom $a\Incl b$  does not have an initial multimodel because the result 
set of $a$ (and $b$) may be arbitrary. The 
initial partial order model will have just one (minimal) element $\und 
a$ which is below $\und b$. The price of this 
generality is that $a$ and $b$ are not sets and, in particular, $a$ is not an element of the set $b$.
 
More significantly, and this applies to multialgebras as well as partial 
orders, initial models can lead to the appearance of additional elements 
not intended by the specifier \cite{c:128}.  In example~\ref{ex:ind} the 
axiom $c: 0\ch 1$ (or $DET(c),\ c\Incl 0\ch 1$) was given for the constant 
$c$.  Its intended meaning is probably that $c$ is an operation which is 
either $0$ or $1$, but we do not (want to) state which.  Because of this 
``do not know which,'' the initial model has to introduce, in addition to 
the elements $0$ and $1$ the extra element $c$, and all three elements 
appear as possible results of $0\ch 1$.  
\begin{Example}
In unified algebras, any such new element will cause occurrence of many others -- 
the definition of a unified algebra as a distributive lattice will force all
the new joins and meets to be included in the model. The initial unified algebra
for the specification with three constants $\{0,1,c\}$ and three axioms 
$\{0:0, 1:1, c:0\ch 1\}$ will look as in the figure to the left. 

\(\maly{1.2}{1.2}
\diagramcompileto{UA1}
& & 0\ch 1 \dlline \drline \\
& 0\ch c \dlline \drline & & 1\ch c \dlline \drline \\
0 \dline & & (0\ch c)\sqcap (1\ch c) \dlline \ddline \drrline \dllline & & 1 \dline \\
0\sqcap (1\ch c)\drline & c \dline \drrline & & & (0\ch c)\sqcap 1 \dlline \\
& 0\sqcap c \drline & 0\sqcap 1 \ullline \urrline \dline & 1\sqcap c \dlline \\
& & 0\sqcap 1\sqcap c \dline \\
& & \perp
\enddiagram
\)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
\(\maly{1.2}{1.2}
\diagramcompileto{UA2}
& & 0\ch 1 \dlline \drline \\
& 0\ch c \dlline \drline & & 1\ch c \dlline \drline \\
0 \drline & & c \dlline  \drline  & & 1 \dlline \\
& 0\sqcap c \drline &  & 1\sqcap c \dlline \\
& & \perp
\enddiagram
\)

\noindent
One may attempt to remove some redundant elements by imposing additional axioms. For 
instance, adding the axiom $0\sqcap 1=\perp$ would result in the model on the
right. Nevertheless, this model still is bound to contain unintended elements
until the new axioms resolve the ambiguity concerning
``what $c$ is supposed to be'', i.e., eliminate the nondeterminism.
\end{Example}
Although formally everything 
is correct as far as initiality is concerned, we may feel justified in 
calling elements such as (those containing) $c$ ``intuitive junk'' 
and thus a violation of the 
``no junk'' dictum which favors initial models in the deterministic case.

The specification of $c$ attempts to indicate that $c$ is equal to $0$
or $1$ without actually identifying $c$ with either of the two. One
wants to model the fact that ``$c=0$ or $c=1$'' without spelling it
clearly out.  This fear originates, of course, in the knowledge that
disjunctive equations do not, in general, allow initial models --
Horn-formulae are the most general ones admitting initial models \cite{c:78,
c:76, c:122}.

The source of the problem is not nondeterminism per se, but the
presence of underspecification and that one insists on using initial
models of such specifications -- {\em deterministic\/} underspecifications
give rise to similar problems. However, in the deterministic case
underspecification is an optional tool for handling exceptional
situations rather than the standard procedure. Typically, one tries to
apply some strategy, such as generator induction \cite{c:genind, c:28, c:44,
c:60}, resulting in specifications with intended initial models.
Nondeterminism, on the other hand, implies disjunction and, with it,
underspecification.

Another aspect of this implication is that the nondeterministic operations themselves are not 
adequately specified. In all three cases, underspecification of the 
$c$ element destroyed $0\ch 1$ as binary choice 
and turned it into an operation capable of returning, besides $0$ and $1$, some $c$. These observations make us 
argue that making a clear distinction between nondeterminism and underspecification and admitting 
disjunctive formulae to handle the latter is more advantageous than it is dangerous. Above all, it would 
allow us to restore the intended simplicity of the model. 

Introducing the lattice structure in unified algebras one avoids disjunction and models it with the help 
of the join operation. It might seem that, since disjunction is the join operation (in the Boolean algebra of 
propositions), the two will lead to similar results. However, the obvious differences are quite significant:
\begin{center}
\begin{tabular}{c@{\ \ }|@{\ \ }c}
	Lattice/Joins	 & Disjunctive specification  \\ \hline
	all joins must be present & 	only relevant disjunctions are 
	included \\
	introduces ``junk'' & 	eliminates ``junk'' \\
	allows initial models &	disallows initial models
\end{tabular}
\end{center}
The first point refers to the fact that in the lattice model join is an operation (choice) with predefined 
semantics. If there are several constants in the specification, say $d$ 
besides $0, 1$ and $c$, then unified algebra is 
forced to interpret the element $a\ch d$ as join. But if we are interested in a binary operation which is only 
some variation of choice, e.g., chooses nondeterministically merely between $0$ and $1$, and for other 
arguments behaves as, say first projection, then we have to relate it to 
the primitive choice operation. $0\ch d$
will always be there. Disjunction allows us to specify different kinds of nondeterministic (also partially 
defined) operations without any reference to some basic form of nondeterminism. The significance of 
disjunctive specifications has been noted by several authors. It has been studied in the theory of data bases 
\cite{c:37, c:124, c:125}, introduced in the theory of algebraic specifications and conditional 
term rewriting \cite{c:42, c:137, c:62}, and utilized for specifications of nondeterminism 
\cite{c:126, c:127, c:130}.

We may treat disjunction as a replacement of the join operation. It will not lead to the lattice models, 
but instead to the standard algebraic models. The most important advantage of this is that it actually 
removes the unintended ``junk'' and produces models (in the initial coverings) which have an intuitive 
clarity comparable to initial models of deterministic specifications. We would (under)specify our example 
in the obvious way:

\begin{Example}\label{ex:dis} 
\[ \begin{array}{l@{\ \ }lll}
	1) &	DET(0)   &     DET(1) &	DET(c)   \\
	2) &	x\Incl x\ch y  & 		y \Incl x\ch y \\
 	3) &	c=0 \lor c=1 \\
	4) &	d \Incl a\ch b
\end{array} \]
\end{Example}

Notice that the choice operator is actually not needed at all in the specification of $c$. Disjunction allows us 
to distinguish $c$ as underspecified from $d$ as a result returned by nondeterministic choice (although we are 
not going into the details here -- see \cite{c:127}). 

The specification of example~\ref{ex:dis} does not have an initial model. Nevertheless, disjunction does not 
spoil initiality completely. Disjunctive specifications always 
possess {\em quasi-initial computational semantics}, 
and mild restrictions on the specifications guarantee existence of 
{\em quasi-initial} multialgebra semantics 
\cite{c:127}. Quasi-initiality generalizes initiality to situations involving ``either ... or ...''. For the above example, 
such a semantics can be summarized by saying that the model class will consist of two parts: the models 
where $c$ equals $0$ ($M0$) and those where it equals $1$ ($M1$). Two 
models, $A0$ and $A1$ given by
\[ \begin{array}{ccccc}
	A0 & & & & 	A1 \\
	\und 0 & \longleftarrow &	a & \longrightarrow & \und 0 \\
	\und 1 & \longleftarrow &	b & \longrightarrow & \und 1 \\
	\{\und 0,\und 1\} & \longleftarrow &	a\ch b & \longrightarrow & \{\und 
	0,\und 1\} \\
	\und 0 & \longleftarrow &	c & \longrightarrow & \und 1 
\end{array} \]
will be initial in the respective components $M0$ and $M1$ of the model class.

Now, the difference between an underspecified $c$ and a nondeterministic 
operation $\ch$ is that the former 
has a unique value in every model, but these values  may vary from one model to another. The latter, on 
the other hand, may also return different values in one model.  $0\ch 
1$  may be thought of as a series of 
distinct applications, each returning either $0$ or $1$. But this means 
that {\em every single application} of $0\ch 1$ is 
underspecified! The final example makes use of this fact to specify 
$\ch$ as a user-defined operator. 
\begin{Example} 
\[ \begin{array}{l@{\ \ }l}
	1) &	DET(0)\ \ DET(1)\ \ DET(c)\ \ DET(d) \\
	2) &	x=(y\ch z) \impl x=y \lor x=z \\
 	3) &	c=0 \lor c=1 \\
	4) &	d \Incl 0\ch 1
\end{array} \]
\end{Example}
Axiom 2 specifies binary choice by underspecifying each particular application of it. It reads: if $x$ is a result 
of (some) application of $y\ch z$ then $x$ equals $y$ or $z$. (Compare 
this to the axiom 2. from example~\ref{ex:dis}.) 
Substituting $0, 1, d$ for $y, z, x$, and using axiom 2. we will get that 
$d$ equals $0$ or $1$. The initial covering of 
the model class will contain the following models: Each of the 
models $A0$ and $A1$ above will now be split into 
two new models depending on whether $\uni(d)=\und 0$ or $\uni(d)=\und 1$. In addition, there will be models where 
$\uni(0\ch 1) = \{\und 0\}$, and $\uni(0\ch 1) = \{\und 1\}$ (these can be excluded 
by adding axioms 2. from example~\ref{ex:dis}). Since $d$ is 
defined in terms of $0\ch 1$, in models where one of these holds, $d$ will 
be equal to the respective $\uni(0\ch 1)$. $c$ 
remains underspecified and so even if $\uni(0\ch 1)=\{\und 0\}$, $c$ may still 
equal $1$. We believe that all these models 
reflect the intuitive possibilities of the specification. In particular, none will contain any redundant 
elements, and the sort will consist of at most $\und 0$ and $\und 1$.
    
The price for this adequacy is, of course, that we no longer have initial semantics. This is the trade-off 
between using disjunction in specifications or excluding it.
The argument favoring disjunctive equations is bolstered by the following observation: The two 
axioms $0\Incl 0\ch 1$ and $1\Incl 0\ch 1$ may be given initial semantics where $0$ and $1$ are the 
only results of $0\ch 1$. However, 
they only say that $0$ and $1$ {\em must} be among the possible results, 
not that they are {\em the only ones}. In the non-initial models of the class any kind of elements may 
occur as the additional results returned by $0\ch 1$. Thus, 
simple (or Horn) formulae can only specify ``lower bounds'' of nondeterminism which coincide with the 
``upper bounds'' only in the initial models.

Horn-specifications also lead to ``necessarily'' nondeterministic implementations. 
The axioms $0\Incl t$ and 
$1\Incl t$ force {\em all} models to be nondeterministic (unless $0$ is identified with $1$). 
They would disallow a model 
which implements $t$ as a deterministic operation returning always only 
$0$ (or only $1$). Implementations of 
a given algebra may restrict only nondeterminism which is not explicitly specified by the axioms. Thus 
one is forced to distinguish between nondeterminism and underspecification, and can not use 
nondeterminism as a pure abstraction mechanism at the specification level. 

\section{Terminal models}\label{se:terminal}
The initial semantics has several well-known limitations. 
\begin{enum}
\item As remarked in the last section, in order to 
ensure the existence of initial models one has to restrict the specification language to conditional 
equations. 
\item On the other hand, initial models yield only special classes of algebras (semicomputable, or, 
in the case of monomorphic specifications, computable ones, see \cite{c:12, c:14}).  
\item It has also been pointed out 
\cite{c:56, c:19, c:21} that, typically, initial structures are not fully 
abstract -- they often distinguish elements which 
behave identically in all contexts, and additional axioms are needed if one wants to identify them.
\end{enum}
Terminal algebra semantics shares two of these limitations. 
\begin{enum}
\item Not all specifications possess terminal models.  According to 
\cite{c:17}, the restriction of the specification language to the positive 
formula (universally or existentially quantified disjunctions or 
conjunctions of positive atomic formula (equations)) guarantees the 
existence of terminal models.  This may easily reduce to the trivial model, 
but the result admits positive specifications relative to some primitive 
(monomorphic) types as long as the specifications are sufficiently complete 
wrt.  these primitive types.  Thus, required inequalities may be introduced 
via the primitive types.  \item Furthermore, the data types obtained by 
terminal semantics are co-semicomputable \cite{c:12, c:14}.
\end{enum}
An advantage of the terminal models is that they do not distinguish 
elements which are observationally equivalent.  Every other model $M$ can 
be seen as a refinement -- an implementation -- of the terminal model $Z$, 
and the unique homomorphism $M\into Z$ serves as the natural abstraction 
function which determines the equivalence on the concrete representations 
of the abstract values.  Focusing on observational equivalence, terminal 
models are often well suited for studying implementation relations.

These properties are carried over to the terminal models of nondeterminate specifications. While 
constructing initial power-set models of nondeterminism poses severe problems, one has at least obtained 
a characterization of the congruence determining the terminal multimodel. Let $B$ be a multimodel of a 
specification $SP$, and $L(B)$ be the class of multimodels of $SP$ such 
that for every $M\in L(B)$ there exists a 
(loose) multihomomorphism $M\into B$.
\begin{Theorem}\label{th:41}{\rm \cite{c:53}.} 
A multimodel $B$ is terminal in the class $(L(B),\MHom)$ iff it identifies all 
consistent values. 
\end{Theorem}
Thus, recalling the definition of consistency from~\refp{eq:cons}, a terminal model has to identify two values 
whenever there is a {\em possibility} that they may give rise to the same observations in all contexts. 

The theorem is qualified by the clause ``$B$ is terminal in $L(B)$'' which means that we still do not have 
the criteria for the existence of terminal models. In particular, the work in \cite{c:53} has a purely semantic 
character and no formal specification language is considered. We may, however, use the theorem to show 
that a terminal model does not exist for a specification $SP$ by showing 
that the class of multimodels of $SP$, 
$\MMod(SP)$, is not equal to the class $L(B)$ for any model $B$ which identifies all consistent values. 

In \cite{c:21} terminal semantics is used to study the implementation relation between four kinds of 
nondeterminism. The programming languages CN, BN, AN, and LN are specified which include, 
respectively, erratic, demonic, angelic, and loose nondeterminism (which, roughly, reflects the idea of a 
specification with loose deterministic semantics). For the definition of these notions a 
predicate ``$loops$'' is 
introduced which expresses the possibility of nontermination 
($loops(s)=\false$ iff $s$ always terminates). The 
terms correspond to the statements of the intended programming language, and the models of the 
specifications represent the possible semantics of the languages. It is shown that the first three, CN, AN, 
and BN, have terminal models. These are of special interest because they are
\begin{enum}
\item {\em minimally defined}, i.e., whenever there is a semantics in which some statement $s$ is 
undefined, then this possibility is reflected in the terminal model where 
$s$ is undefined too, 
and
\item {\em fully abstract}, i.e., two statements which have the same 
$loops$ values and the same result sets are equal.  
\end{enum}
LN does not have a terminal model, but all minimal models of LN are 
possible {\em deterministic} semantics of 
LN and are possible implementations of some of the terminal models of CN, AN or BN.  The 
implementation ordering $\leq_{l}$ on models is defined in the natural way \cite{c:93, c:53, c:18}: 
$M \leq_{l} N$  iff  for all terms $t$, elements $a$:
\begin{itemize}\MyLPar 
\item[{}] $loops(t^{N})=\false \impl loops(t^{M})=\false$	
\item[{}]  $a^{M} \in \res{t^{M}}\impl a^{N}\in \res{t^{N}}$ 
\end{itemize}
That is, $M$ implements $N$ if it terminates at least in the situations when $N$ terminates and is not more 
nondeterministic than $N$. The result states then that the terminal models for AN and BN are incomparable 
but both are possible implementations of the terminal model of CN. This reflects exactly our intuition 
about the relation between these forms of nondeterminism. Erratic nondeterminism (CN) is the most 
general and both angelic (AN) and demonic (BN) ones are possible specializations. Angelic and demonic 
nondeterminisms are, of course, mutually exclusive -- neither subsumes the other. Finally, any 
nondeterminate operation which does not require fairness may be implemented (loosely) by a 
deterministic operation.

We may look at this result as a semantic counterpart of the complexity analysis of nondeterministic 
computations from \cite{c:25}. Different kinds of nondeterminism are there classified according to the 
complexity of their $loops$ predicate. Unbounded erratic nondeterminism is the most complex class which 
can be fully characterized only by $\Sigma^{1}_{1}$ formulae, while angelic nondeterminism (bounded as well as 
unbounded) requires only $\Pi^{0}_{1}$ formulae. Of course, the deterministic 
programs are simplest in this respect -- they do not require the 
$loops$ predicate at all since it can be uniquely determined from their input-output 
relation (which in all cases is of the same, partial recursive 
complexity, $\Sigma^{0}_{1}$). Other, more specific forms of 
biased nondeterministic computations are also included in the classification in \cite{c:25}.

The reader is referred also to \cite{c:19, c:20} for more details about the general approach on which the results 
from \cite{c:21} are based.

\section{Solutions of recursive equations -- continuous models}\label{se:cont}
One of the reasons for the great importance of the initial models is that they, in a sense, ``represent'' the 
whole class of models. In particular, equality on the ground terms in an initial model ``represents'' the 
equality on such terms in all models. In order to check whether a ground equation holds in some model $A$ 
we can check whether it holds in the initial one, and if it does conclude that it holds in $A$. Equations of a 
specification define the operations which are legal interpretations of the operation symbols. In particular, 
recursive equations define operations -- namely operations which, when substituted for the operation 
symbols in the equations, provide a solution to the equational system. The next natural question is: can 
such solutions be constructed effectively?

The theory of the deterministic languages and specifications knows the 
``Mezei-Wright-like results'' 
(after \cite{c:88}) of the form: there is a (symbolic, initial) structure 
$\Terms$ such 
that the following give the same result:
\begin{enum}
\item solving a system of recursive equations over $\Terms$ and interpreting the solution in another 
structure $A$, and
\item interpreting the system in $A$ and solving it directly.
\end{enum}
One of the main results of this kind for the equational specifications is given in \cite{c:40} 
for $\Terms$ the initial continuous model.   
We will summarize briefly the ideas of such a construction and some difficulties in extending it to the 
nondeterministic case. The issue is especially relevant because it focuses on the problems of 
nontermination, finite observability and computability and allows us to identify some connections 
between the algebraic and the denotational approaches to semantics. 

\subsection{Deterministic preliminaries}
Let $\Sigma$ be a determinate signature. Any term $t\in\XTerms X$ can be 
considered a tree $\tree t$ reflecting its syntactic 
structure. A term defined by recursion may be considered as a, potentially infinite, tree obtained by the 
stepwise unfolding of the term along its defining equations. An additional 
symbol $\perp$ is used to indicate the  ``unfinished'' unfolding. 
\begin{Example}\label{ex:51} 
Define $f:\Nat\into\Nat$ by $f(0) = 0$ and $f(x+1) = f(x)+2$.
The tree for $f(3)$ is constructed by applying the definition to 
$\perp$ until no $\perp$ elements occur in the tree:
\[
\maly{2}{1.5}
\diagram 
\sdrop{f(3)} & & & & & \sdrop{f(2)+2} & & & & & & \sdrop{(f(1)+2)+2} & & & & & & &
    \sdrop{((f(0)+2)+2)+2} & & & & & & & \sdrop{((0+2)+2)+2} \\
\perp &\xto[rrr]& & & & + \dlline \drline & &\xto[rrr]& &&& + \dlline\drline & &\xto[rrr]& 
        &  & & & + \dlline \drline  &   &\xto[rrr]& & & & & + \dlline \drline  &    \\
&&   & & \perp & & 2              &&  & & + \dlline \drline & & 2  &&&
          & & + \dlline \drline & & 2  &&&  & & + \dlline \drline & & 2     \\
&&   &   & &  &  &&         &  \perp & & 2 &  &&&
          & + \dlline \drline & & 2 &  &&&  & + \dlline \drline & & 2 &     \\
&&  & & & &   && & & &  &                   & &&  \perp & & 2 & &  & &&  0 & & 2 & & 
\enddiagram
\]
\end{Example}
If there is a possibility of infinite unfolding, then the semantics is obtained as the fixed point of the 
defining equations. For this purpose, the structure of $\Sigma$-algebras is enriched with the appropriate ordering 
to make them {\em complete partial orders} (cpo).
 
An infinite unfolding may lead to an {\em infinite term} so the carriers 
must contain elements interpreting such terms.  The ordering must ensure 
that unfoldings constitute increasing chains: in particular, $\perp$ is the 
least element, and the operations are required to be continuous.  Then, by 
the Knaster-Tarski theorem (e.g., \cite{c:75}), unfoldings have the least 
fixed points which may be computed starting with the least element $\perp$.  
Such a {\em computational (approximation) ordering}, $\cpo$, on terms 
$\XTerms\perp$ is defined as follows \cite{c:40, c:77, c:23, c:96, c:15, 
c:97}: \[
\begin{array}{r@{\ \ \ \ \ }l@{\ \ }l}
{\rm C:} & s \cpo t\ \ \ {\rm iff\ } & 1.\ s\syeq t\ \  {\rm\ or} \\
 & & 2.\ s \syeq \perp\ \ {\rm\ or} \\
 & & 3.\ s\syeq f(p_{1},\ldots,p_{n}),\ t\syeq 
 f(r_{1},\ldots,r_{n}),\ {\rm and\ for\ all\ } i : p_{i}\cpo r_{i}
 \end{array}
 \]
Notice the natural interpretation of the unfolding in the above example as a gradual approximation to the 
final result by successive evaluation of the ``currently 
undefined'' $\perp$ leaves. This intuition is reflected by $\cpo$ in 
that a term $s$ is $\cpo$-less (computed) than $t$ if $t$ can be obtained from $s$ by substituting ``better defined'' terms 
for some occurrences of $\perp$ in $s$.

The model class $\tree Alg_{\Sigma,\perp}$ is defined by requiring
that every model $\tree A_{\Sigma,\perp}$ is $\cpo$-continuous (i.e.,
the carrier is a $\cpo$-$cpo$ and all operations are
$\cpo$-continuous).\footnote{We are using hat $\tree{{\_}}$ to
indicate continuous structures or their elements. The additional
symbols in the subscript, as in $A_{\Sigma,\perp,\ch}$, indicate the
additional operations, not present in $\Sigma$, which are interpreted in
the $\Sigma$-structure $A$.} Similarly, the homomorphisms of models are strict
$\cpo$-continuous $\Sigma$-homomorphisms. The point of these
requirements is that when all operations are $\cpo$-continuous the
unfoldings are chains and have $lub$'s, and such $lub$'s are preserved
by the homomorphisms between models.

Technically, $\cpo$-continuous models are obtained by {\em ideal
completion} \cite{c:75, c:40} of standard models partially ordered by
$\cpo$. Every partially ordered algebra $A_{\Sigma,\perp}$ with a
least element $\perp$ (for each sort) can be homomorphically embedded
into a continuous algebra $\tree A_{\Sigma,\perp}$ with the carrier
being the set of all ideals of $A_{\Sigma,\perp}$ (i.e., downward
closed subsets $J$ such that any two elements of $J$ have an upper
bound in $J$) ordered by set inclusion. The embedding is the mapping
${\tree{{\_}}}:A_{\Sigma,\perp}\into \tree A_{\Sigma,\perp}$ which
sends every element $a$ of $A$ to the ideal generated by $a$, i.e.,
the set of all $b\in A_{\Sigma,\perp}$ such that $b\cpo a$.
 
Intuitively, we may think of this construction as adding the
``infinite elements'' as the limit points of chains in
$A_{\Sigma,\perp}$. In particular, for the initial $\Sigma$-word structure
$\XTerms\perp$ we obtain the continuous structure $\tree\XTerms\perp$ (of finite
and infinite terms) which is initial in $\tree Alg_{\Sigma,\perp}$.
Consequently, given some continuous
algebra $\tree A_{\Sigma,\perp}$ and a system of recursive equations, instead of
\begin{itemize}\MyLPar
\item[1.]
interpreting the terms from the equations in the algebra by the unique
$\Sigma$-homomorphism $\uni:\XTerms\perp\into\tree A_{\Sigma,\perp}$,
and then constructing the $lub$ of the chain in $\tree
A_{\Sigma,\perp}$, \vspace*{-1ex}
\end{itemize}
the least solution of recursive equations in $\tree A_{\Sigma,\perp}$ can be constructed by
\begin{itemize}\MyLPar
\item[2.] finding the $lub$ of the unfolding chain in $\tree\XTerms\perp$ 
and mapping it by the unique 
continuous homomorphism $\tree\uni$ to $\tree A_{\Sigma,\perp}$.
\end{itemize}
The content of the Mezei-Wright-like theorem can be summarized as:
\begin{Theorem}\label{th:MW} 
{\rm \cite{c:40}.} Given an 
algebra $\tree A_{\Sigma,\perp}$, there
are three $\Sigma$-homomorphisms with $\tree\uni$ continuous, 
such that the following diagram commutes:
\[ \scol{-1pc}
\diagramcompileto{02MW}
 & \XTerms\perp \dlto_{{\tree{{\_}}}} \drto^{\uni} \\
\tree\XTerms\perp \rrto^{\tree\uni} & & \tree A_{\Sigma,\perp}
\enddiagram \]
\end{Theorem}

\subsection{CPO's for nondeterministic choice}\label{sub:cpo}

Let $(\Sigma,\ch,\perp)$ denote a (determinate) signature $\Sigma$ extended, 
as above, with $\perp$, and with the nondeterministic 
binary choice $\ch$. The first generalization of theorem~\ref{th:MW} 
to nondeterminism is given in \cite{c:77} which we have discussed 
briefly in subsection~\ref{sub:PO}. The generalization is quite straightforward. 
The ordering $\cpo$ is defined by the same axioms $C$ 
and so $lub$'s exist and are computed in the same way regardless of whether 
terms involve occurrences of $\ch$ or not.

\begin{Example}\label{ex:53} 
Define $f(x)  =  f(x+1) \ch x$. The (infinite) $lub$ tree for $f(x)$ is the fixed point of the same unfolding 
process as in example~\ref{ex:51}. 
\[
\maly{2}{1.5}
\diagramcompileto{03choice}
\perp &\xto[rrr]& & & & \ch\dlline\drline & &\xto[rrr]& &&& \ch\dlline\drline & &\xto[rrr]& 
        &  & & & \ch\dlline \drline  &   &\xdotted[rrr]& & & & & \ch\dlline \drline  &    \\
&&   & & \perp & & x              &&  & & \ch\dlline \drline & & x  &&&
          & & \ch\dlline \drline & & x  &&&  & & \ch\dlline \drline & & x    \\
&&   &   & &  &  &&         &  \perp & & x+1 &  &&&
          & \ch\dlline \drline & & x+1 &  &&&  & \ch\dlline \drline & & x+1 &     \\
&&  & & & &   && & & &  &      & &&  \perp & & x+2 & &  & &&  \ch\dldotted\drdotted & & x+2 & & \\
&&&&&&&&&&&&&&&&&&&&&&&&&&
\enddiagram
\]
\end{Example}
Nondeterminism is encoded in the result ordering $\Incl$ which is defined 
by the axioms R from subsection~\ref{sub:PO}.  Unlike in the (Hoare, Smyth, 
Plotkin) power domain constructions, the two orderings are not merged into 
one, but are kept apart.  Turning $\Incl$ into a $cpo$ might present new 
difficulties, such as an additional bottom element, and would bring us very 
close to the denotational definitions of the combined orderings.  Instead, 
it is shown that the ordering $\Incl$ is ``compatible'' with $\cpo$ in the 
sense that, if $\{a_{i}\}, \{b_{i}\}$ are two $\cpo$-chains such that for 
all $i: a_{i}\Incl b_{i}$, then $a\cpo b$, where $a$, $b$ are the 
$\cpo$-$lub$'s of the respective chains.  The intuitive content of this 
``compatibility'' is that the two computations (computational chains) which 
at each step have $\Incl$-ordered results are $\cpo$-ordered as 
computations.

Recall that axiom R3 (from subsection~\ref{sub:PO}) made all the operations monotonic with respect to the result 
ordering. Homomorphisms are now required to be not only strict and 
$\cpo$-continuous, but also $\Incl$-monotonic. 
In general, quotients of continuous algebras are not continuous. However, it may be shown that in the 
special case of the congruence generated by the axioms JC, JA, JI 
(subsection~\ref{sub:primitive}) the quotient $\tree 
T_{\Sigma,\ch,\perp}$ of $\tree\XTerms{\ch,\perp}$ 
is initial in the class of $\cpo$-continuous, $\Incl$-monotonic models. 
This initiality result yields the desired analog of 
theorem~\ref{th:MW}. 

The simplicity of this generalization relies on the fact that models
are here, as we said, essentially deterministic. Also, the nature of
$\ch$, although modeled to some extent by the result partial order,
does not fully correspond to choice. There will be cases (and not very
rare, as a matter of fact, for instance, the one from
examples~\ref{ex:union}-\ref{ex:unionb}) when a model of $\ch$ does
not correspond to the intuition of choice. This means, that the
obtained result does not have the desired consequences if we attempt
to interpret specifications in some power-set structures.  The
counterintuitive implications of this definition may be expressed as
follows: the approximation partial ordering $s\cpo t$ intends to say
that the computation of $t$ extends -- has gone further than -- that
of $s$, and thus has brought us closer to a definite result. In the
above scenario, the further we move along $\cpo$, the more
applications of $\ch$ we may encounter. But each such application
indicates a choice, i.e., two new possibilities. Thus the further we
move along $\cpo$, the less definite the result becomes!
\begin{Example}\label{ex:54a} 
Compare the intended
meaning of the tree $\tree t$ when the term $t$ is determinate and
when it contains applications of $\ch$.
Let $b:\into S,\ f:S\into S,\ g:S\times S\into S$
be determinate operations, and consider the trees for the terms 
$t\syeq f(g(\perp,b))$ and $s\syeq f(\perp\ch b)$:
\[ \maly{1.5}{1.5}
\diagramcompileto{04tree}
\tree t\ \syeq & f\dline & & & & & \tree s\ \syeq & f\dline \\
  & g \dlline\drline & & & & & & \ch\dlline\drline \\
\perp & & b & & & & \perp & & b
\enddiagram
\]
$\tree t$ represents an incomplete evaluation which requires a substitution 
of some closed term for $\perp$ in 
order to represent the unique result of the computation (singular semantics is assumed). The 
intuitive interpretation of $\tree s$, on the other hand, would say that 
the $\ch$ node represents a branching 
of the computation which may proceed either toward $b$ -- in which case we have a complete 
computation, or toward $\perp$ -- in which case we do not have one. 
It would not consider $s$ as a single 
syntactic tree $\tree s$, but rather as a pair of trees, each representing 
a possible result of the evaluation of $s:$
 \[ \maly{1.5}{1}
 \diagramcompileto{05tree}
 \tree s_1\ \syeq & f\dline & & & & & \tree s_2\ \syeq & f\dline \\
       & \perp & & & & &  & b
 \enddiagram
 \]
\end{Example}
In short, the branching of a tree at deterministic terms (such as in
$\tree t$) has a different meaning than the branching at $\ch$ in
$\tree s$. The set interpretation of the latter is quite natural and
most authors do interpret it this way \cite{c:82, c:97,
c:23}. Unfortunately, the formalization of this intuition causes
serious problems.

As the example suggests, we would like to define a mapping, 
$\Psi:\tree\XTerms{\ch,\perp} \into \PSet(\tree \XTerms\perp)$ sending a (possibly 
infinite) term $\tree t$ to the set of its result trees, i.e., trees 
where $\ch$  has been replaced by the chosen branches, 
and such that the following diagram commutes: 
\[ \scol{-1pc}
\diagramcompileto{06MW}
 & \tree\XTerms{\ch,\perp} \dlto_{\Psi} \drto^{\Psi_A} \\
\PSet(\tree\XTerms\perp) \rrto^{\tree\uni} & & \PSet(\tree A_{\Sigma,\perp})
\enddiagram \]
where: 
\begin{enum}
\item $\tree A_{\Sigma,\perp}$ is a continuous $\Sigma$-algebra and $\PSet(\tree A_{\Sigma,\perp})$ is the power-set of its carrier. 
Notice that $\tree A_{\Sigma,\perp}$ is deterministic since
$\ch\not\in\Sigma$.
\item $\tree \uni:\tree\XTerms\perp\into \tree A_{\Sigma,\perp}$ 
is the interpretation of the determinate terms  
in $\tree A_{\Sigma,\perp}$. It is shown in \cite{c:96} that such a 
continuous interpretation can be obtained as a unique extension of the interpretation of finite 
terms $\XTerms\perp\into A_{\Sigma,\perp}$.
\item $\tree\uni: \PSet(\tree\XTerms\perp)\into \PSet(\tree A_{\Sigma,\perp})$
is the pointwise extension of 2. to sets. 
\item\label{it} $\Psi_{A}$ is a ``direct interpretation'' of terms involving 
$\ch$ in $\PSet(\tree A_{\Sigma,\perp})$ which should satisfy:
   \begin{enum}
    \item\label{i} $\Psi_{A}(t) = \res{\uni(t)}$ for all $t\in\tree\XTerms\perp$
    \item\label{ii} $\Psi_{A}(t\ch s) = \Psi_{A}(t) \cup \Psi_{A}(s)$
    \item\label{iii} $\Psi_{A}(f(t_{1}\ldots t_{n}) = \bigcup_{a_{i}\in 
    \Psi_{A}(t_{i})} f^{A}(a_{1}\ldots a_{n})$
    \end{enum}  
\end{enum}
Equations \ref{i}-\ref{ii} require that $\Psi_{A}$ 
interprets $\ch$ as the set of results obtained by performing all choices in the 
term, and ~\ref{iii} requires singular semantics of the arguments.

If there exists such a $\Psi$ which is continuous then we can construct 
the $lub$ in $\tree\XTerms{\ch,\perp}$, map it on the set 
of the result trees in $\PSet(\tree\XTerms{\perp})$ and interpret the elements 
of the latter in $\tree A_{\Sigma,\perp}$, or, alternatively, interpret the 
equation using $\Psi_{A}$ in $\PSet(\tree A_{\Sigma,\perp})$ and solve it there. 
Commutativity of the diagram and the equations \ref{it} ensure 
that the results obtained in these two ways will be the same and, by the 
continuity of $\Psi$ and $\tree\uni$, will yield 
$lub$ in $\PSet(\tree A_{\Sigma,\perp})$. 
The continuity requirement on $\Psi$ demands a definition of an 
ordering on $\PSet(\tree\XTerms{\perp})$. 
Unfortunately, Broy reports the following result
\begin{Claim}\label{prop:nocont} 
{\rm \cite{c:23}.} There does not exist an ordering on $\PSet(\tree\XTerms{\perp})$ 
such that $\Psi$ is continuous. 
\end{Claim}
Notice, that the ordering $\cpo$ on $\tree\XTerms{\ch,\perp}$ is not flat. 
The problem here is the same as in defining an adequate 
ordering making power domains of non-flat domains $cpo$'s. We sketch two solutions of this problem. The 
first one modifies the structure $\PSet(\tree\XTerms{\perp})$ so that an appropriate ordering can be defined. 
The second relaxes 
the continuity requirement and, instead, applies more refined techniques of finding fixed points.  

For the finite terms the situation is rather simple and equation 
\ref{ii} will, for instance, make $\Psi(s)$ from 
example~\ref{ex:54a} return the two expected trees $\tree s_{1}$ and $\tree s_{2}$. 
To envisage a general solution Boudol introduced 
\cite{c:16, c:97} {\em choice} trees for terms containing $\ch$. In addition to the chosen branches choice trees also keep a 
record of discarded branches.
\begin{Example}\label{ex:54b} 
The choice trees for $s \syeq f(\perp\ch b)$ will be:
\[ \maly{1.5}{1.5}
\diagramcompileto{07tree}
\tree s_1\ \syeq & f\dline & & & & & \tree s_2\ \syeq & f\dline \\
  & L \dlline\drline & & & & & & R \dlline\drline \\
\perp & & erase & & & & erase & & b
\enddiagram
\]
\end{Example}

$L$(eft), $R$(ight) and $erase$ are the new symbols added to the alphabet for indicating which of the branches of 
the original syntactic tree has been selected. 
The ordering on the choice trees is again $\cpo$. For a $\tree t \in 
\tree\XTerms{\ch,\perp}$
denote by $CT(\tree t)$ the set of the choice trees of $\tree t$ and define the mapping 
$\psi: \tree\XTerms{\ch,\perp} \into 
\PSet(\tree\XTerms{L,R,erase,\perp})$ by $\psi(\tree t) = CT(\tree t)$.
This mapping is still not continuous (and it can be shown, analogously to 
proposition~\ref{prop:nocont}, that no ordering for 
the target can make it continuous). 
But a slight modification yields the desired continuity. 
Let $CT_{\Sigma,\perp}= \{ (\tree t,\tree c) : \tree t\in 
\tree\XTerms{\ch,\perp}, \tree c\in CT(\tree t)\}$ ordered by $(\tree 
t, \tree c)\cpo (\tree t_{1},\tree c_{1})$ iff $\tree t\cpo \tree
t_{1}$ and $\tree c\cpo \tree c_{1}$.  I.e., each element of
$CT_{\Sigma,\perp}$ contains information about both ``definedness'' of
the computation (in $\tree t$) {\em and} the actual choices which have
been made (in $\tree c$).  The relation $\cpo$ on $CT_{\Sigma,\perp}$
takes then into account not only the absence of the $\perp$ leaves --
requiring that $\tree t_1$ be ``better defined'' than $\tree t$ -- but
also the fact that the sequence of choices $\tree c_1$ of this ``more
computed'' element is actually a continuation of the choices $\tree c$
made in the ``less computed'' $\tree t$. Thus it combines the
original intention of the approximation partial ordering with the 
intuition that the development along
this ordering amounts to discarding some branches and continuing
along the chosen ones towards more and more definite result.

Now, order $\PSet(CT_{\Sigma,\perp})$ by the
Egli-Milner extension
\cite{c:33} of $\cpo$, i.e., $\forall S,T\in
\PSet(CT_{\Sigma,\perp}):$
\eq{
T\cpo_{EM}S\ \iff\ (\forall tc\in T\ \exists sc\in S : tc\cpo sc)\ 
\land\ (\forall sc\in S\ \exists tc\in T : tc\cpo sc)
}\label{eq:EM}
Then the mapping $\Psi$, defined as $\Psi(\tree t) = \{(\tree t,\tree 
c) : \tree c\in CT(\tree t)\}$ is continuous.

The possible dissatisfaction with the fact that the intermediate
structure introduced by the $L, R$ and $erase$ symbols had to be used,
and that the final structure is not $\PSet(\tree\XTerms\perp)$ is
resolved in \cite{c:23}. Broy shows there that, although no continuous $\Psi$
exists, one can find a continuous mapping into the Plotkin power
domain \cite{c:103} which factors through $\Psi$.\footnote{More precisely, one uses
an appropriate representation of the Plotkin power domain, where elements
are simply subsets of the elements of the underlying domain.} Let
$\Plot(\tree A_{\Sigma,\perp})$ denote the Plotkin power domain over
$\tree A_{\Sigma,\perp}$, $\Plot$ be the mapping $\PSet(\tree
A_{\Sigma,\perp})\into\Plot(\tree A_{\Sigma,\perp})$ sending each set
on its representation in the power domain, and let $\tree{{\cal C}}$ send
sets of $\tree A_{\Sigma,\perp}$ to their closures (i.e., for
$B\in\PSet(\tree A_{\Sigma,\perp}),\ \tree{{\cal C}}(B)$ contains least upper
bounds and greatest lower bounds of, resp. upward and downward
directed, subsets of $B$). Then there exists a $\Psi_{A}$ such that
$\Plot\circ\Psi_{A}$ is continuous with respect to the Egli-Milner
ordering, $\Psi_{A}$ satisfies the equations ~\ref{it}, and such that
the following diagram commutes
\[ \scol{-1pc}
\diagramcompileto{08MW}
 & \tree\XTerms{\ch,\perp} \dlto_{\Psi} \drto^{\Psi_A} \\
\PSet(\tree\XTerms\perp)\dto^{\Plot} \rrto^{\tree\uni\circ\tree{{\cal C}}} & & \PSet(\tree A_{\Sigma,\perp})\dto^{\Plot} \\
\Plot(\tree\XTerms\perp) \rrto^{\tree{\uni}\circ\tree{{\cal C}}} & & \Plot(\tree A_{\Sigma,\perp})
\enddiagram 
\]
Commutativity of the upper triangle of this diagram is the 
required Mezei-Wright-like result. One can 
interpret a term $\tree t\in \tree\XTerms{\ch,\perp}$ using $\Psi_{A}$
directly in $\PSet(\tree A_{\Sigma,\perp})$ as a set of the elements of 
$\tree A_{\Sigma,\perp}$, 
or else interpret $\tree t$ as a set of 
trees over $\XTerms\perp$ which are then interpreted in $\tree A_{\Sigma,\perp}$. 
Notice that all sets in the image of $\Psi_{A}$ (and $\Psi$) are closed. 
This extends the notion of finite observability -- if all finite approximations 
of an element $s$ are in the set $\Psi_{A}(\tree t)$ then so is $s$. 

The construction of $\Psi_{A}$ involves finding fixed points in
$\Plot(\tree A_{\Sigma,\perp}), {\sf S}(\tree A_{\Sigma,\perp})$ (the
Smyth power domain \cite{c:117}) and taking the minimal function
approximating the former and approximated by the latter. For the
details of this construction, we refer the reader to \cite{c:22, c:23}. An
extensive selection of both introductory and advanced material on
power domains and continuity of the nondeterministic choice can be
found in \cite{c:106, c:110, c:118, c:5, c:99, c:105, c:3, c:31, c:18, c:48}.  The discussion
above was concerned with singular (IO) semantics only. Detailed
comparison of the Mezei-Wright-like results for IO vs. OI algebras can
be found in \cite{c:34, c:35}.


\section{Reasoning Systems}\label{se:reasoning}
As the variety of the proposals discussed so far indicates, the semantics of nondeterminism is certainly not 
a closed research topic. This is perhaps one of the reasons why relatively little work focuses on the 
reasoning about nondeterminism. Initially, one attempted to reduce such reasoning to reasoning about 
some deterministic equivalents. These attempts are the topic of 
subsection~\ref{sub:red}. Only very recently some authors 
began to design systems for direct reasoning about nondeterminism. We give an example of such a system 
in subsection~\ref{sub:nondet}. The following section~\ref{se:rew} discusses the reasoning systems based on rewriting.

\subsection{Reduction to determinism}\label{sub:red}
The early approaches attempted to effect a reduction of the nondeterministic axioms to the semantically 
equivalent deterministic ones and to apply the standard forms of reasoning to the latter. In 
\cite{c:121} such a 
translation is given for a specification language with equality interpreted as set equality. In order to specify 
nondeterministic operations one also allows {\em characteristic 
predicates} describing the result sets. These 
predicates, although a part of the specification, are not, strictly speaking, a part of the specification 
language. (They are similar to the ``semantic functions'' $loops$ and 
$elem$ from \cite{c:21}, or $breadth$ from \cite{c:18}.)
\begin{Example}\label{ex:61} 
Binary nondeterministic choice \\[1ex]
\hspace*{2em}	$\ch: \Nat\times \Nat\into \Nat$  \\[1ex]
can be specified with the help of the predicate \\[1ex]
\hspace*{2em}
	$\pred\ch : \Nat\times\Nat\times\Nat\into\bool$. \\[1ex]
$\pred\ch(x,y,z)$ is to be true iff $z$ is a possible result 
of $x\ch y$. So we define: \\[1ex]
\hspace*{2em}	$\pred\ch(x,y,z)  =  (x=z\lor y=z)$
\end{Example}

The problem of reasoning with the nondeterminate terms arises because they do not have the 
{\em substitutivity property}. Variables refer to the elements of the semantic domain while nondeterminate 
terms denote sets of such elements. The characteristic predicate specification above is reasonable only 
because the variables $x, y, z$ refer to single values and not sets (or arbitrary terms). Thus the substitution of 
$x\ch y$ for $z$, although consistent with the signature and syntactically correct, is not really meaningful since it 
yields
\[
\pred\ch(x,y,x\ch y)  =  (x=x\ch y \lor y=x\ch y), 
\]
which would make choice return always the first or always the second argument. In a sense, the predicates 
are at a different syntactic level of the specification than the (nondeterminate) terms.  The formulae one 
reasons about are equations, and predicates are used only to make the following 
translation \cite{c:121} into the first 
order language possible. 

Let us consider the equation:
\eq{x\ch y = y\ch x \label{eq:a}}
Equality is interpreted as set equality, so the translated determinate formula will be:
\eq{ \label{eq:aa}
\begin{array}{rl}
  &  \forall z_{1}: (\pred\ch(x,y,z_{1}) \impl \exists 
   z_{2}:(\pred\ch(y,x,z_{2})\land z_{1}=z_{2})) \\
\land &   
   \forall z_{2}: (\pred\ch(y,x,z_{2}) \impl \exists 
   z_{1}:(\pred\ch(x,y,z_{1})\land z_{1}=z_{2}))
\end{array} }
It would be rather annoying to write the general translation pattern 
for equality, but the above example 
illustrates the point. It says: \refp{eq:a} holds iff for every possible 
result $z_{1}$ returned by $x\ch y$ there exists a result $z_{2}$ 
returned by $y\ch x$ such that $z_{1}=z_{2}$, and vice versa.

``Elementwise'' reasoning can then be carried out in full first order
logic. Denote the result of translating an equation $e$ by $FOL(e)$
(for First Order Logic). All equational axioms $e$ of the
specification are translated into $FOL(e)$ and a formula $a$ is valid
iff $FOL(a)$ follows from the derived axioms. One can save some work
by avoiding translation of deterministic terms and carrying them
directly to the derived formulae. However, it is in general
undecidable whether a given nondeterminate term is deterministic or
not \cite{c:18}, so such an improvement would be limited to a
syntactic check on the occurrences of nondeterminate subterms.

$FOL$ will leave all logical symbols except for ``$=$'' unaffected,
e.g., $FOL(\neg e) = \neg FOL(e)$, $FOL(e_{1}\lor e_{2}) =
FOL(e_{1})\lor FOL(e_{2})$, etc. Using this observation, \cite{c:64}
generalizes $FOL$ to conditional equations.  Let $b$ be a boolean
expression in the specification language (not a characteristic
predicate), $e$ an equation. The translation of $b\impl e$ is defined
as $FOL(b=\true)\impl FOL(e)$.  For instance, take $b\syeq 0 < 0\ch
1$, and consider the conditional formula:
\eq{	0 < 0\ch 1\impl e \label{eq:b}}
It will be translated as
\eq{
(\forall z:(\pred\ch(0,1,z)\impl 0<z) \land \exists z: 0<z )\ \impl\ 
FOL(e) \label{eq:bb}
}
All nondeterminate subexpressions of $b$ are replaced with new 
variables ($0<z$) and these are bound in the 
characteristic predicates ($\pred\ch(0,1,z)$) to be the results of the corresponding operations. Then the condition of 
\refp{eq:bb} is true if $b$ holds for all possible results of its nondeterministic subexpressions (and there exists a value 
making $b$ true -- this, apparently superfluous, conjunct is obtained automatically 
by applying $FOL$ to $b=\true$). 
The consequent is just the translation of the consequent of 
\refp{eq:b}.
 
Since $0\not< 0$ the antecedent of \refp{eq:bb} is false and so 
\refp{eq:b} will be considered true. This may not quite be
what we intended when writing \refp{eq:b} since we could have been
interested in making $e$ hold only in the cases when $0\ch 1$ returns
$1$. The translation enforces a uniform interpretation of boolean
expressions -- they are either true or false, but not
indeterminate. This reflects a general assumption made in \cite{c:64}
that boolean expressions are, at most, weakly nondeterministic -- for
any argument (a single value) they can be evaluated
nondeterministically, but their result must be uniquely determined by
the arguments. For instance, a boolean operation $b(x)$ defined as
$0<x$ would be legal, but the one defined as $0\ch 1<x$ would not.
The restriction is motivated by the fact that boolean expressions are
used there for handling exceptions, but it also indicates the
limitations of the approach.

\subsection{Calculus of nondeterminate terms}\label{sub:nondet} 
It is far from pleasing that starting with an equational specification, and being interested only in its 
equational consequences, one has to apply full first order logic. But it seems that the complexity of the 
equational logic of nondeterminism exceeds by far the complexity of classical equational reasoning. 
Other systems which can deal with nondeterminism, especially variants of modal logics (temporal logic 
\cite{c:83, c:10, c:71}, dynamic logic \cite{c:47, c:36, c:46}),  are based on conceptual models which are much more complex 
than one would expect, and wish, for a logic of simple specifications with equations/inclusions.  

An elegant contribution is that of unified algebras which, being based exclusively on Horn clauses, 
offer the possibility of taking full advantage of the existing tools for reasoning about Horn 
specifications. The idea, however obvious, is only implicit in the presentation 
of unified algebras -- the 
framework is based on the notion of institutions and deliberately abstracts from the peculiarities of the 
reasoning systems which might possibly be coupled with it. 

As mentioned before, the main problem with nondeterminate terms is that they cannot be freely 
substituted for the (singular) variables. This introduces highly non-standard features into logics of 
nondeterminism. The only, to our knowledge, calculus for direct reasoning about nondeterminism which 
has been shown complete wrt. the multialgebraic semantics is given in 
\cite{c:126, c:127}. The calculus, $NEQ$, can 
be used for reasoning about disjunctive clauses where each clause $C$ is a set of atomic formulae 
(i.e., the ordering and multiplicity of the atomic formulae do not matter), 
written as $e_{1},\ldots,e_{n}$. A clause is 
interpreted as the disjunction of its literals. 

The atomic fomulae $e$ in $NEQ$ are inclusions ($s\Incl t$),
equalities ($s\doteq t$), and inequalities ($s\# t$). Equalities are
understood to mean {\em necessary} equality, i.e., the two terms {\em
always} return the same result.  $\pr s\doteq t$ means not only that
$t$ and $s$ are equal, but also that they are deterministic, and $\pr
t\doteq t$ holds only for the deterministic terms. (Thus it is element
equality and the symbol ``$\doteq$'' is used instead of ``$=$'' to
emphasize the distinction w.r.t. standard equality). Inequalities are
understood to mean {\em necessary} inequality, i.e., the two terms {\em
never} return the same results.  Variables are singular and a clause
$C=\{e_1,...,e_n\}$ is satisfied iff the formula $\forall
x_{i}:e_{1}\lor\ldots\lor e_{n}$ is satisfied, where the $x_{i}$ are
all the variables in $C$.  Equations and inclusions are called
positive atoms, and inequations negative atoms. The latter act as
negations of both equalities and inclusions. (A slightly different
language where the negation of equality does not coincide with the
negation of inclusion is used in \cite{c:130}.) For instance, a clause $\{t\#
s, p\Incl r\}$ is thought of as the (equivalent) conditional formula
$\neg(t\# s) \impl p\Incl r$, stating that $p$ is included in $r$
whenever $t$ intersects $s$.  

The introduction of inequalities is motivated by the need for {\em 
binding} the applications of 
nondeterministic operations, and thus distinguishing between the terms treated as 
sets and the results of 
particular applications of terms corresponding to individuals. A 
formula $\pr 0\ch 1\doteq 0, 0\ch 1\doteq 1$ says that $0\ch 1$ is a 
set which is either equal to $0$ or to $1$, in other words, $0\ch 1$ is not 
nondeterministic, merely underspecified. 
In order to express nondeterminism, one has to indicate that not the 
whole set, but an arbitrary application of 
(element of the set) $0\ch 1$ equals $0$ or $1$. This is expressed by the binding: 
\eq{	 x\# (0\ch 1), x\doteq 0, x\doteq 1 \label{eq:62} } 
(I.e., for any value $x$, $x$ is either one of $0$ and $1$, or it is
not a possible result of $0\ch 1$.) Thinking of terms as sets, an
inequality $\ldots s\# t\ldots$ is a short form for $\ldots z\in s,
z\in t\ldots$, where $z$ is a new variable, and the inequation in
\refp{eq:62} corresponds to requiring $x\in 0\ch 1$ in the clause.
The two inclusions $1\Incl 0\ch 1$ and $0\Incl 0\ch 1$ have the
expected multialgebraic meaning which, together with the above
disjunction, will force $0\ch 1$ to be interpreted in all models
exactly as the set $\{0,1\}$. Horn-formulae (clauses with exactly one
positive atom) are a special case of clauses and the obvious
restriction of the calculus below can be applied to this case. The
rules of the calculus are as follows :
\[ \begin{array}{rll}
R1: & a)\ \pr x\# y, x\doteq y & b)\ \pr x\# t, x\Incl t\ \ \ \ \ x,y\in\Vars 
\\[2ex]
R2: & \prule{\pr C[x/t]\ \ ;\ \ \pr D,s\doteq t}{\pr C[x/s], D} 
\\[2ex]
R3: & \prule{\pr C[x/t]\ \ ;\ \ \pr D,s\Incl t}{\pr C[x/s], 
D} & x\ {\rm not\ in\ a\ right\!\!-\!\!hand\ side\ of\ }\Incl{\rm\ in\ }C 
\\[2ex]
R4: & \prule{\pr C, s\preceq t\ \ ;\ \ \pr D,s\# t}{\pr C, D} & 
\preceq {\rm\ is\ one\ of\ }\Incl,\ \doteq
\\[2ex]
R5: & \prule{\pr C}{\pr C,e}  \\[2ex]
R6: & \prule{\pr C,x\# t}{\pr C[x/t]} &
x\in\Vars\setminus\Vars[t],\ {\rm at\ most\ one\ }x{\rm\ in\ }C
\end{array}
\]
\noindent
Uppercase Latin letters $C, D$, denote single clauses and lowercase
Latin letters $a, e$ atomic formulae.  Semicolon indicates a
conjunction of clauses. E.g., if $C$ is $\{c_{1}, ..., c_{n}\},\ D$ is
$\{d_{1}, ..., d_{m}\}$, and $a$ is an atomic formula, then ``$C ;
D$'' denotes the conjunction $\{c_{1}, ..., c_{n}\}\ \land\ \{d_{1},
..., d_{m}\}$, while ``$C, D$'' denotes the clause $\{c_{1}, ...,
c_{n}, d_{1}, ..., d_{m}\}$.  Similarly, ``$C, a$'' is the clause
$\{c_{1}, ..., c_{n}, a\}$, and ``$C ; a$'' is the conjunction $C
\land \{a\}$.  $C[x/t]$ denotes $C$ with $t$ substituted for $x$.
 
A few comments regarding the rules may be in order.
\begin{itemize}\MyLPar
\item[R1] expresses the relation between $\#$, equality and inclusion. 
Since variables $x$ and $y$ are individuals, the 
 axioms a) and b) correspond to, respectively, $x\not= y\lor 
 x=y$ and $x\not\in t\lor x\in t$. They also reflect the fact that 
 ``$\doteq$'' is a partial equivalence relation and is reflexive only for variables.  
\item[R2] is a paramodulation rule allowing replacement of deterministic 
terms (in the case when $s\doteq t$ holds in 
the second assumption). In particular, it allows derivation of the standard substitution rule when the 
substituted terms are deterministic, and prevents substitution of nondeterministic terms for variables.
\item[R3] allows ``specialization'' of a clause by substituting for a term 
$t$ another term $s$ which is included in $t$. The 
restriction that the occurrences of $t$ which are substituted for don't 
occur in the right-hand side of $\Incl$ in $C$ 
is needed to prevent, for instance, the unsound conclusion $\pr p\Incl 
s$ from the premises $\pr p\Incl t$ and $\pr s\Incl t$.
\item[R4] $s\# t$ implies both negation of $s\doteq t$ and of $s\Incl 
t$. R4 allows us to resolve these complementary atoms.  
\item[R5] is the standard weakening rule.
\item[R6] eliminates redundant bindings, namely those that bind an application of a term occurring at most once 
in the rest of the clause.
\end{itemize}
The main result concerning this calculus is its soundness and completeness:

\begin{Theorem} 
{\rm\cite{c:127, c:126}.} For any specification $SP: \MMod(SP)\models C \iff 
SP\pr_{NEQ} C$.
\end{Theorem}
The tight relation between multimodels and functional models referred to 
in proposition~\ref{prop:26} is further 
strengthened by the fact that the same theorem holds when we replace 
$\MMod$ by $\FMod$. In \cite{c:130}, a variant of this calculus is studied which
is sound and complete wrt. power-algebra and plural semantics.

In \cite{c:Bia1, c:Bia} a very similar calculus is introduced. It operates on
a slightly different language with inclusions, but without 1-element
equalities, and with local bindings in terms (i.e., terms of the form
`$let\ x=t\ in\ s(x)$').  Interestingly, modifying merely the side
condition on the rule R6 by requiring {\em exactly one} occurrence of
$x$ in $C$, the authors obtain sound and complete calculus with
respect to partial multialgebras (where operations may return empty
sets).

\section{Operational models and rewriting}\label{se:rew}
Many authors approach the problem of reasoning about algebraic specifications using some form of 
rewriting. Rewriting systems have at least two features distinguishing them from the general form of 
reasoning discussed in section~\ref{se:reasoning}:
\begin{enum}
\item they focus on (and are much more amenable to) automation and
\item they may be also seen as a way of giving the operational semantics to the specifications.
\end{enum}
Nondeterministic operations have the inherent computational ingredient which deterministic 
functions lack: their result depends on the actual computation since nondeterministic decisions are made 
only when the program is executed. The power-set constructions model this by considering all possibilities 
in one single model. An operational interpretation, on the other hand, incorporates the fact that 
nondeterminism is resolved during computation into the semantic structure.

Such a structure is given by a {\em reduction system} which simulates the evaluation of terms (programs). 
Different interpretations of the objects being reduced (as strings, sequences, graphs) and different reduction 
strategies give rise to a variety of operational semantics. 

\subsection{Non-confluence and restricted substitutivity}\label{sub:71}
The main idea is to simulate the computation by allowing a nondeterminate term to reduce to any of its 
possible result. For instance, the reduction rules for the binary choice will be:
\eq{
x\ch y \rew x\ \ \ \ \ {\rm and}\ \ \ \ \ x\ch y \rew y \label{eq:71} }
This idea is applied in various operational semantics for the
denotational models and $\lambda$-calculus. In \cite{c:66, c:67} the
computation sequences (simulating sequences of nondeterministic
choices), rather than the result sets, are introduced as the basis for
a power domain construction. In \cite{c:70} a similar semantics is
shown equivalent to the operational semantics of bounded
nondeterminism. \cite{c:5} considers a generalization to unbounded
nondeterminism and points out that power domains based on the
computation sequences help solve the problem of non-continuity of
unbounded nondeterministic choice. In \cite{c:3, c:105} noncontinuity
is tackled by the generalization of the semantics of the iterative
construct to fixed points over transfinite ordinals (according to the
suggestion from \cite{c:99}), and the resulting Plotkin and Smyth power
domains for countable nondeterminism are shown equivalent to the
respective operational semantics. An operational interpretation of
$\lambda$-calculus extended with the choice operator can be obtained
by appropriate modifications of the $\beta$-rule. Such modifications,
leading to both plural and singular semantics, are discussed, for
instance, in \cite{c:49, c:73, c:4}. We will base the following discussion on the
terminology of the systems for term rewriting which constitute a
natural counterpart to the algebraic specifications.

Since $x$ and $y$ in \refp{eq:71} may be arbitrary terms, in particular 
both may be in {\em normal form} (not 
reducible by the rules of the system) rewriting with nondeterminism will 
be, typically, {\em non-confluent} \cite{c:24, c:59, c:57, c:97, c:4, c:87}. 
One may simply accept it as a fact of life -- after all, a nondeterministic computation is 
precisely one which can return several results, and each rewrite represents one among them 
\cite{c:59, c:4, c:87}. 
Nevertheless, one may try to show some desirable properties of the resulting system. 
For instance, in \cite{c:4}  
the authors show that their rewriting system is confluent for all terms 
not involving $\ch$, and that for all 
terms the possible rewrites constitute exactly the set prescribed by the independently defined model. In 
the cases when the semantics of a specification is defined also by non-operational means the latter 
correspondence between the set obtained by all possible rewritings of a term and the set assigned to this 
term by the static semantics is, of course, an obligation. 
Inclusion of the former in the latter yields 
soundness and the opposite inclusion completeness of the reasoning by rewriting.  

An exception to the schema~\refp{eq:71} is the work of Kaplan \cite{c:63}. It actually forbids rules like these, 
except for the one rule of distributivity of $\ch$ over function application 
(JD from subsection~\ref{sub:primitive} oriented from left to 
right). Instead, terms in normal form may involve $\ch$. For instance, one may define an operation $f$ by the 
rule $f\rew a\ch b$. If $a$ and $b$ are irreducible $a\ch b$ will be the normal form of $f$. 
Rewriting is then performed 
modulo the equations for associativity and commutativity of $\ch$ with the rules corresponding to other join axioms (JI and JE). 
This leads to the possibility of obtaining unique normal forms for the 
nondeterminate terms (with bounded nondeterminism) and the conditions for such systems to be confluent are 
given. An interesting property of such confluent systems is that their initial models are isomorphic to the 
intuitive multialgebra models with $\ch$ interpreted as set union. 

One of the issues raised by virtually any work on rewriting is the
distinction between the singular and the plural semantics of parameter
passing \cite{c:34, c:35, c:49, c:4, c:73}.  The need to decide when
the arguments of the terms under evaluation are to be reduced makes
this distinction natural, not to say unavoidable. The two evaluation
strategies are present already in the rewriting of deterministic terms
\cite{c:43, c:98}. Most generally, the singular semantics requires the
arguments to be evaluated before the enclosing operation call (IO),
while the plural one postpones their evaluation until the enclosing
term has been reduced in its entirety (OI). This gives the two
substitution rules:
\eq{
f(x)[x/t]_{IO}\rew{\textstyle{\bigcup}} \{f(s) : s\in t\}
}\label{eq:IO}\vspace*{-2.5ex}
\eq{
f(x)[x/t]_{OI}\rew f(t)
}\label{eq:OI}
$[x/t]$ means substitution of $t$ for all occurrences of $x$. 
We have adopted the rather informal notation $f\rew\{\ldots\}$ to indicate 
that $f$ can be rewritten to any element of 
the set on the right-hand side of $\rew$, and $s\in t$ to say that $s$ 
is (one of) the normal forms of $t$.  For instance, let $f(x)\rew 
x+x$ and $t\syeq 0\ch 1$.
 Evaluation of $f(t)$ under IO requires that we first find all the rewrites 
 of $0\ch 1$, and will give us 
 \[
 f(x)[x/0\ch 1]_{IO}\rew \{f(x)[x/0]_{IO}, f(x)[x/1]_{IO}\}\rew \{f(0),f(1)\} \rew \{0,2\}
 \]
OI, on the other hand will yield 
\[
 f(x)[x/0\ch 1]_{OI}\rew f(0\ch 1) \rew 0\ch 1 + 0\ch 1 \rew \{0,1,2\}
 \] 
OI is a much simpler mechanism than IO. The latter requires that the argument $t$ be first reduced to 
(some of) its normal forms $s$ before $f(t)$ can  be evaluated. Furthermore, all such normal forms must be 
deterministic in order for IO to yield the singular semantics! For 
if $t$ can be reduced to a nondeterminate 
normal form $s$ then $f(x)[x/t]_{IO}$ will be reduced to a set 
$\{...,f(s),...\}$ and then to $\{...,s+s,...\}$. Thus, having the 
singular semantics in mind, one must, in addition to designing an IO rewriting system, make sure that the 
system, as well as the specification, satisfy some additional conditions. Such conditions are given by 
Hu{\ss}mann in \cite{c:59, c:58}. The rewriting system must satisfy the condition that any substitution of a term $s$ 
for a variable $x$ be guarded by the prior proof that $s$ is 
deterministic, $DET(s)$. The responsibility of the 
specifier is to ensure that all terms do have a deterministic normal form, 
i.e.:\\[1ex]
. \hfill $\forall t\in\GTerms\ \exists s\in\GTerms : t \rewc s \land 
DET(s)$ \hfill (DET-completeness) \\[1ex]
where $\rewc$ is the transitive closure of $\rew$. One more condition is needed to ensure the singular semantics. 
Any (deterministic) result obtained from a term $f(t)$ must be a result obtained by making some choices 
during the evaluation. The rule $f(0\ch 1) \rew c$ does not determine singularity 
of the argument passed to $f$. If $c$ 
is to be produced in the singular semantics from $f(0\ch 1)$ it must be 
the result of either $f(0)$ or $f(1)$. This 
requirement, termed DET-additivity, is ensured if the specification with the rewriting rules $R$ satisfies two 
conditions: \\[1ex]
.\ \hfill $ \begin{array}{lr@{\ \ :\ \ }l}
	1. & \forall\ l\rew r \in R & l\syeq f(t_{1}\ldots t_{n}) \land 
	\forall i: DET(i) \\
	2. & \forall f(t_{1}\ldots t_{n}) & DET(f(t_{1}\ldots t_{n}) ) \impl 
	DET(t_{i}) \end{array} $ \hfill	(DET-additivity) \\[1ex]
Besides the rules with single variable in the left-hand side, 1. forbids 
the rules like $f(0\ch 1) \rew c$ and requires that one 
writes instead two  rules $:f(0)\rew c$ and $f(1)\rew c$. Analogous requirement
of left $\ch$-freeness is made in \cite{c:63}. 2. 
says that an operation $f$ with the nondeterministic arguments is capable of returning a set of possible 
results. This is again the condition analogous to one made by Kaplan in \cite{c:63}. Compared with the latter 
work the system of Hu{\ss}mann's \cite{c:59} is much less restrictive since in \cite{c:63} it is also required that rules be 
left-linear, i.e., contain no multiple occurrences of a variable in LHS. 
The rewriting system of Hu{\ss}mann is 
shown to be sound and (weakly) ground complete with respect to the model class $(\MMod,\MHom)$ of 
DET-complete and DET-additive specifications. The calculus of 
subsection~\ref{sub:nondet} is sound and complete for 
specifications without the restrictions to DET-completeness and DET-additivity.

What makes nondeterministic OI so much simpler than IO is the fact that the models of the former 
are essentially deterministic power algebras. Hence, the variables in OI refer to sets which are just 
individuals of the carrier. This is succinctly expressed in:
\begin{Claim} 
{\rm \cite{c:34}.} OI substitution is associative, i.e.: 
\[
f(\ldots x...y\ldots z\ldots) ([x/t][y/s])[z/p]_{OI} = f(\ldots x\ldots 
y\ldots z\ldots) [x/t]([y/s][z/p])_{OI}. 
\]
\end{Claim}
A simple example shows that this is not the case for the IO substitutions:\\[1ex]
\hspace*{1.5em} $
(x + y) ([y/x][x/0\ch 1]) [x/0\ch 1]_{IO} = (x + y) [y/0\ch 1] 
[x/0\ch 1]_{IO} = \{0,1,2\} \not= 
 $ \\[.5ex] 
\hspace*{1.5em} $
(x + y) [y/x] ([x/0\ch 1][x/0\ch 1])_{IO} = (x + x) [x/0\ch 1] [x/0\ch 
1]_{IO} = (x + x) [x/0\ch 1]_{IO} = \{0,2\}
$ \\[1ex]
The lack of associativity of IO substitutions is the reason for the complications of the rewriting systems 
referred to above. The problem does not arise if there is always at most one occurrence of a variable to be 
substituted for or if the substituted terms are deterministic. 
\begin{Claim}{\rm \cite{c:34}.} 
If 

	1. there is at most one occurrence of the variable to be substituted for, or 
	
	2. any substituted term is deterministic \\
then IO substitution is associative. 
\end{Claim} 
1. is reflected in the systems requiring linearity, i.e., forbidding multiple occurrences of a variable, which is 
a very strong restriction (\cite{c:63}, the introductory system in \cite{c:58}), and 
2. in the systems, like Hu{\ss}mann's, 
which require a proof of determinacy for the substituted terms. (The calculus 
from subsection~\ref{sub:nondet} takes 
care of both cases: the restriction on the rule R6 corresponds to 1, and 
the second premise in rule R2 to 2.
In \cite{c:130} it is also shown that a complete extension of the calculus to plural arguments requires only 
the addition of the standard, unrestricted substitution rule for plural variables.)

Of course, one of the main differences between IO and OI strategies
concerns, as in deterministic rewriting, the termination
properties. Since the former requires the evaluation of all arguments
before the evaluation of a call, it will diverge in many cases in
which the latter will compute a well defined result.  One of the
numerous variations on the plural/singular vs. OI/IO distinctions is
proposed in \cite{c:4}. It combines the singular semantics of
parameter passing with the preferable termination properties of the OI
evaluation strategy by means of sharing. The idea is to bind (share)
the arguments and postpone their evaluation until reduction of the
term requires a value of the argument (lazy evaluation). The language
(of $\lambda$-expressions, actually, but we stay with our notation) is
extended with the binding construct $\{x/t\}$ which is performed
before substitution:
\eq{
	f(x) [x/t]_{\beta} \rew f(x) \{x/t\}
\label{eq:bind1} }
The rest of the system takes then care of rewriting $f$ and $t$ as far as possible, e.g., 
\eq{ \begin{array}{cccl}
	{\rm if} & f(x)\rew f'(x)  & {\rm then} & f(x)\{x/t\}\rew 
	f'(x)\{x/t\} \\
	{\rm if} & t \rew t'  &{\rm then} & f(x)\{x/t\} \rew 
	f(x)\{x/t'\} \end{array}
\label{eq:bind2}  
}
``As far as possible'' is defined with the help of the critical set, $CR$, of a term. $CR(t)$ is empty whenever $t$ can 
be rewritten and contains the variable $x$ if further rewriting of $t$ demands $x$ to be evaluated. The rule
\eq{
	 {\rm if\ }  x\in CR(f(x)) {\rm\ then\ } f(x)\{x/t\} \rew f(x)[x/t]
}\label{eq:bind3} 
performs then the usual substitution $[x/t]$ of $t$ for all 
occurrences of $x$ in $f(x)$. By the rules~\refp{eq:bind2}, $t$ in the moment of such 
substitution will be in normal form.  

\subsection{Rewriting Logic}\label{sub:RL}
A very powerful and general theory of nondeterministic (and concurrent) rewriting called Rewriting Logic 
was designed by Jos\'{e} Meseguer in \cite{c:87, c:86}. 

As we have seen, purely equational specifications of nondeterminism do not yield intuitively plausible 
results. Defining choice by $x\ch y=x$, and $x\ch y=y$ gives $x=y$. On the other hand, 
the definition $x\ch y=x \lor x\ch y=y$ 
does not have an initial model. This motivates the use of inclusion 
(subsections~\ref{sub:inclusion}-\ref{sub:unified}) or rewrite rules as above. The 
language of rewriting logic extends the equational language by allowing also conditional rewrite rules. 
Equations may be considered two-way rewrite rules, but the idea is to simplify the exposition by rewriting 
in equivalence classes modulo the congruence induced by the equations and to use rewrite rules for 
nondeterministic terms only. The generalization of the rewriting systems for equational theories lies in 
allowing conditional rules and labeling the rules (we discuss this point in a moment). 
A rewrite system $S$ is 
given by a 4-tuple $(\Sigma, E, L, R)$ of signature, equations, labels, and rewrite rules labeled by $L$.
\begin{Example}\label{ex:RL} 
For illustration, we will use the following system $S$ for the natural numbers with binary choice 

$ \begin{array}{rrrcl}
 \Sigma: & 0: & & \into & \Nat \\
        & s: & \Nat & \into & \Nat\\
        & +: & \Nat\times\Nat & \into & \Nat\\
        & \ch : & \Nat\times\Nat & \into & \Nat \\
E:   & 1. & \multicolumn{3}{l}{0+x = 0} \\
     & 2. & \multicolumn{3}{l}{x+y = y+x} \\
     & 3.  & \multicolumn{3}{l}{s(x)+s(y) = s(s(x+y))} \\
     & 4. & \multicolumn{3}{l}{x\ch y = y\ch x} \\
L:  & \multicolumn{4}{l}{\{ r1, r2 \} } \\
R: &	r1: & x\ch y \rew x	 \\
   & 	r2: & x\ch y \rew y
\end{array} $
\end{Example}

\para{Rewriting logic}
Rewriting logic ($RL$) is the following set of rules ($[t]$ denotes 
the equivalence class of $t$ under the 
congruence induced by $E$; $t_{i}, s_{i}, w_{i}, v_{i}\in \XTerms X$) :
\[ \begin{array}{l@{\ \ }l}
{\rm RL1.\  Reflexivity} & [t] \rew [t] \\[1ex]
{\rm RL2.\ Congruence} & \prule{[t_{i}]\rew [s_{i}]}{[f(t_{i})] \rew 
[f(s_{i})]} \\[2.5ex]
{\rm RL3.\ Replacement} & \prule{[w_{i}]\rew [v_{i}]}{[t(w_{i})] \rew 
[s(v_{i})]}\ \ \ \  {\rm for\ each\ rule\ } r: t(x_{i}) \rew 
s(x_{i}) \in R \\[2.5ex]
{\rm RL4.\ Transitivity} & \prule{[t_{1}]\rew [t_{2}]\ \ \ 
[t_{2}]\rew [t_{3}]}{[t_{1}]\rew [t_{3}]}
\end{array}
\] This is the whole logic and its simplicity and intuitive appeal call for 
no further comments.  (We have simplified the rule RL3 which, in general, 
involves conditionals.)  As in most systems discussed above, a proof in 
$RL$ will produce a possible result of the argument, for instance, RL1 and 
RL3 will give $[(x\ch y)+z]\rew [x+z]$ (using $r1$), and $[(x\ch y)+z]\rew 
[y+z]$ (using $r2$).

\para{The model $\RLSX$} 
The semantics of $RL$ is given in categorical language -- \cite{c:Bar} is a standard 
introductory text, \cite{c:Bor, c:Mac} are more advanced presentations.

A model of a system $S$ is constructed as a category $\RLSX$ with the objects 
being the equivalence classes $[t]$ 
for $t\in\XTerms X$, and the morphisms the equivalence classes of the terms 
representing proofs in $RL$. In order to 
identify appropriate proof terms (and possibly distinguish two morphism with the same source and target) 
the labels of the rules applied are used. The morphisms are generated using 
the rules ``simulating'' the proof 
rules of $RL$ which, in addition, attach the appropriate label to each morphism: 
\[ \begin{array}{l@{\ \ }l}
{\rm 1.\  Identities} & [t] : [t] \rew [t] \\[1ex]	
{\rm 2.\ }\Sigma{\rm-structure} & \prule{\alpha_{i} : [t_{i}]\rew 
[s_{i}]} {f(\alpha_{i}) : [f(t_{i})] \rew [f(s_{i})]} \\[2.5ex]
{\rm 3.\ Replacement} & \prule{\alpha_{i} : [w_{i}]\rew [v_{i}]} {r(\alpha_{i}) : [t(w_{i})] \rew 
[s(v_{i})]}\ \ \ \  {\rm for\ each\ rule\ } r: t(x_{i}) \rew 
s(x_{i}) \in R \\[2.5ex]
{\rm 4.\ Composition} & \prule{\alpha : [t_{1}]\rew [t_{2}]\ \ \ 
\beta : [t_{2}]\rew [t_{3}]}{\alpha;\beta : [t_{1}]\rew [t_{3}]}
\end{array}
\]
A morphism $\gamma: [t]\rew [s]$ corresponds then to a proof (term) which, 
by applying the rules $\gamma$, starts with $[t]$ 
and produces $[s]$. To make a category out of this one needs to ensure the associativity of compositions and 
to make the morphisms $[t]$ into the identities on the objects $[t]$. The following axioms take care of 
imposing the required properties on the morphisms:  \\[.5ex]
\hspace*{2em}
\begin{tabular}{rr@{\ \ :\ \ }l}
(assoc)  &	for all $\alpha, \beta, \gamma$  &  $(\alpha; \beta);\gamma = 
\alpha ; (\beta ; \gamma)$ \\[.5ex]	 
(ident)  &     for all $\alpha: [t] \rew [s]$ &  $\alpha ; [s] = 
\alpha$ and $[t]; \alpha = \alpha $ \\[.5ex]
\end{tabular}

\noindent 	
Some additional axioms make sure that the appropriate morphisms will be identified. 
For instance, axiom 
4. makes $[0\ch 1] = [1\ch 0]$, and hence the morphisms $r1([0],[1]): 
[0\ch 1] \rew [0]$, and $r2([1],[0]): [0\ch 1] \rew [0]$ 
should be identified. 
In particular, all equations from $E$ should be valid in the model category, so for every 
equational axiom $t(x)=s(x)$ and all $\alpha$ we require that the morphisms 
$t(\alpha)$ and $s(\alpha)$ be equal. This will make, 
for instance, $+([0],[x])$ equal to the identity morphism $[x]$ for all $x$.  
\begin{Example} 
A small piece of the category $\RLSX$ for $S$ from example~\ref{ex:RL} is shown below: 
\[ \scol{5em} 
\diagramcompileto{09RL}
 \bullet \ddrto^<<<<<<<<{r2([0],[1])}  \ddto_{r1([0],[1])}  \ar@(ur,ul)[]_{[0\ch 1]}
  & \bullet \ddto|{s(r1([0],[1]))} \ddrto^<<<<<{s(r2([0],[1]))} \ar@(ur,ul)[]_{[s(0\ch 1)]} 
  & \bullet \ddto^{r2([1],[2])} \ddlto^>>>>>>{r1([1],[2])}  \ar@(ur,ul)[]_{[1\ch 2]}
\\ \\
 \bullet  \ar@(dr,dl)[]^{[0]} & \bullet \ar@(dr,dl)[]^{[1]} & \bullet \ar@(dr,dl)[]^{[2]}
\enddiagram
\]
\end{Example}

Note that the object $[s(0\ch 1)]$ is not the same as $[1\ch 2]$. This reflects the ability of the model to 
distinguish between plural semantics (which is default) from the singular which would require the 
additional distributivity axiom $s(x\ch y) = s(x)\ch s(y)$.

\noindent
The last thing is to interpret the $\Sigma$-structure in $\RLSX$. 
Two final identifications are: \\[.5ex]
\hspace*{2em}
\begin{tabular}{rr@{\ \ :\ \ }l}
(comp)  &	for all $f, \alpha_{i}, \beta_{i}$  &  $f(\alpha_{i}; 
\beta_{i}) = f(\alpha_{i}) ; f(\beta_{i})$ \\[.5ex]	 
(ident)  &     for all $f, t_{i}$ &  $f([t_{i}]) = [f(t_{i})]$ \\[.5ex]
\end{tabular}

\noindent 	
With these equations, every $f\in\Sigma$ determines a functor  
$f_{\RLS} : \RLSX^{n}\into \RLSX$ (where $n$ is the arity of $f$). 
For 
instance, $s$ will determine the functor which sends every object $[t]$ 
to $[s(t)]$, and every morphism, 
like $r1([0],[1])$, to the respective morphism $s(r1([0],[1]))$.
 
\para{The category of $S$-models}
$\RLSX$ is just one among the possible models of $S$. For a 
category {\sf C} to be an $S$-model it must satisfy all the 
axioms of $S$. Intuitively this means that \\[.5ex]
\hspace*{2em}1. for every $t=s \in E$, the functors $t_{\sf C}$ and $s_{\sf C}$ induced 
in {\sf C} should be identical, \\
\hspace*{2em}2.  for every $[t] \rew [s] \in R$, there must exist a corresponding arrow 
in {\sf C}. \\[.5ex]
Since $t$ and $s$ may involve variables, 2. is formalized as the requirement of the existence of a natural 
transformation between the respective functors $t_{\sf C}$ and $s_{\sf C}$. 
Finally, the notion of a morphism of $S$-models is 
defined as an $S$-functor which preserves the $\Sigma$-structure and the natural transformations corresponding to 
each rule of $S$. This gives a category $\SCAT$ of all models 
of $S$. One of the central results about these 
constructions is:
\begin{Theorem}{\rm \cite{c:87}.} 
The functor $\SCAT\into {\sf Set}$ sending an $S$-model to the set 
of its objects has the 
left adjoint which sends each set $X$ to $\RLSX$.     
\end{Theorem}
The first thing one obtains from this theorem is an easy proof of
completeness of $RL$ with respect to $\SCAT$ (of course, $RL$ is
also sound for this class).  It also suggests a generalized initial
semantics for rewrite systems since any system $S$ has now the initial
model $\RLS$.  The list of various approaches which can be subsumed
under rewriting logic is quite impressive. We only mention the link to
few other topics discussed in this paper: the classical initial algebras,
partially ordered and continuous models.

Given a standard rewriting system $S$ one can construct the initial model 
for $S$ provided it is confluent. 
The present construction assigns an initial model to any $S$ 
system -- also the ones which involve 
nondeterminism in the form of non-confluent rewrite rules (or are not confluent 
for other reasons). If $S$ 
happens to determine an initial algebra $T_{S}$, or, more generally, if we are interested in the initial 
model $T_{S}$ 
of the equational theory corresponding to $S$ , then $T_{S}$ may be obtained 
as a quotient of $\RLS$. The equational 
theory for $S$ is the one where all $\rew$ have been turned into =. This means that all we have to do is to impose 
such equalities on the morphisms (representing $\rew$) in $\RLS$. We unlabel 
all morphisms and make 
\eq{\label{eq:eq}
[t]=[s]\ \ \ {\rm if}\ \ \ \exists \alpha: [t]\rew [s]
}
The image of $\RLS$ under this transformation will be $T_{S}$. In fact, the 
transformation is a functor $F_{{\sf Alg}_{S}}$ sending $\SCAT$ onto the 
class ${\sf Alg}_S$ of ordinary $\Sigma$-models of the 
equational theory of $S$.

This identification of morphisms by imposing additional
equations~\refp{eq:eq} is only a special case of a more general
construction. It establishes connections between the partial order and
denotational models on the one hand, and the rewriting based,
operational models on the other.

Given a rewrite system $S$ and the category $\SCAT$ of
all its models with the initial model $\RLS$, imposing additional
identities on morphisms we obtain a subcategory ${\sf
C} \refl \SCAT$. By a general result
\cite{c:BarT}, this subcategory is reflective, which in particular means that the inclusion
functor has a left adjoint $F_{{\sf C}}: \SCAT \into {\sf C}$
preserving initial objects (this was the functor $F_{{\sf Alg}_{S}}:\SCAT\into {\sf Alg}_S$
above). Thus for any reflective subcategory {\sf C}, we will obtain
initial object ``for free.''

In particular, imposing the identities between any two parallel and any two opposite arrows, 
i.e. (for an arrow $\alpha:[t]\rew[t']$, $\src(\alpha)$ is its source $[t]$ and
$\trg(\alpha)$ its target $[t']$):
\eq{\label{eq:quot}
\begin{array}{r@{\ \ \ {\rm if}\ \ \ }l@{\ \land\ }l}
 \alpha = \beta & \src(\alpha)=\src(\beta) & \trg(\alpha)=\trg(\beta)
 \\ \alpha = \beta & \src(\alpha)=\trg(\beta) &
 \trg(\alpha)=\src(\beta) \end{array} 
} 
we obtain a subcategory of
 $S$-partial orders, $\SPO\refl\SCAT$, where ordering in each object 
reflects the rewriting relation $:[s]\cpo_{RL}[t]\iff
 [s]\rew[t]$.  By further requiring the objects of $\SPO$ to be
 $cpo$'s, and all homomorphisms to be $\cpo_{RL}$-continuous, we
 obtain a subcategory of complete $S$-partial orders,
 $\CPOS\refl\SPO$ which is known to be reflective (by an independent
 result, e.g.~\cite{c:Bloom}, since it is not obtained here by mere
 additional equalities). The left adjoint to this inclusion is given
 by the ideal completion bringing us from a partially ordered algebra
 to a $cpo$ ($\CPOS$ here corresponds to $\tree Alg_S$ from
 subsection~\ref{sub:cpo}).  Finally, identification of all morphisms
 in a (weakly) connected component, i.e., equation~\refp{eq:eq}, leads
 to the category ${\sf Alg}_S$ of the usual $S$-algebras where
 we have reinterpreted all $\rew$ as $=$.  We thus obtain quite a
 unifying view of equational, partially ordered, $cpo$ and $RL$ models
 given by the chain of reflective subcategories for a given system
 $S:$
\[ \srow{-1.7pc}
\diagram
\CPOS \drto|<\hole|<<\ahook \\
& \SPO \rto|<\hole|<<\ahook & \SCAT \\
{\sf Alg}_S \urto|<\hole|<<\ahook 
\enddiagram
\]
Notice however, the significant difference between this view of
(complete) partial orders for nondeterminism and the one presented in
subsections~\ref{sub:PO}, \ref{sub:unified} and \ref{sub:cpo}.  The
result partial order $\cpo$ defined by axioms $R$ (page~\pageref{def:R})
made $x\cpo x\ch y$, i.e., it reflected the subset relation. This
caused the problems in combining it with the approximation partial
order described in subsection~\ref{sub:cpo} (before
example~\ref{ex:54a}).  Here, the ordering is reversed, i.e., $x\ch y
\cpo_{RL} x$ (because $x\ch y\rew x$), which reflects the operational character 
of this ordering -- $x$ is a ``more definite result'' which can be obtained 
in the course of computing $x\ch y$.


\subsection{Reasoning and rewriting with sets}\label{sub:sets} 
The rewriting relation $t\rewc s$, interpreted in the equational case
as the equality of $t$ and $s$, has been redefined for the
nondeterministic rewriting to mean that $t$ is {\em possibly} equal to
$s$ (or that $s\Incl t$). As we have seen, an immediate consequence is
a lack of confluence. Since $\Incl$ is not an equivalence relation,
this poses a more general question of rewriting in the presence of
such relations. In particular, inclusion is just one among the common
set-relations. Thus reasoning about nondeterminism becomes closely
related with reasoning with sets (as observed in \cite{c:129}) -- an
area of increasing importance, especially in logic and constraint
programming \cite{c:114, c:32, c:61, c:120}. The suggested extensions
go in the direction of {\em rewriting atoms} -- pairs of terms
annotated with an appropriate relational symbol -- rather than
rewriting of terms.

The authors of {\em bi-rewriting\/} \cite{c:72} propose the use of two kinds of relations:  
$\reww{\subset}$ and $\reww\supset$. To prove $t\Incl s$, one 
will try to rewrite $t$ to a term $u$ replacing it by ``bigger'' terms 
along the relation $\reww{\subset}$. Simultaneously, one 
tries to rewrite $s$ to $u$ replacing it by ``smaller'' terms along the 
relation $\reww{\supset}$. Existence of such a $u$ (which 
need not be unique) proves the inclusion. The use of two relations gives more flexibility in applying 
different simplification orderings because now the ordering of terms need not coincide with their 
inclusions $\Incl$.
 
A related approach from \cite{c:69, c:69a} introduces a language for specifying the 
relations: $\Incl$, $\frown$, and $\doteq$ which, 
interpreted in multialgebras, correspond to inclusion, intersection and identity of 1-element sets. The 
associated reasoning is based on the replacement and compositional properties of these relations. A sound 
and refutationally complete system for the language of clauses over such atomic relations is 
given. Rewriting is done using the corresponding relations: 
$\reww\subset$, $\reww\supset$, $\reww\frown$ and $\reww\doteq$. In particular, in the course of a 
rewriting proof the predicates may change according to the laws of their composition, yielding all the 
time the strongest possible relation between the active terms. For instance, two rewriting steps 
$t\reww\supset s$ and $s\reww\subset u$ will lead to a derivation of 
$t\reww\frown u$, while the steps $t\reww\supset s$ and $s\reww\doteq 
u$ will yield $t\reww\supset u$.
 
The above works extend the equational rewriting generalizing several classical notions such as 
overlapping rules, critical pair, confluence. In particular, the notion of unique normal form becomes less 
central. Instead, one has to invent a search strategy which finds appropriate atoms/terms for chaining 
proofs (such as the term $u$ in $s\reww\supset u$ and $t\reww\subset u$ 
needed to complete the proof of $t\Incl s$).

\section{Summary}\label{se:sum}
Nondeterminism poses many problems which cannot easily be incorporated into the framework of 
deterministic specifications. The formalization of the intuition that nondeterministic operations generate 
sets of possible results, reflected in the power-set structures, presents serious difficulties. 
The proposed 
generalizations of the classical results such as those on initiality, continuity, and equational reasoning to 
the power-set structures have only limited validity. The most successful proposals are rather sophisticated 
and apply to non-standard constructions. They are often very general, addressing other problems besides 
that of nondeterminism. 

The fundamental difficulty seems to lie in the inherently computational character of nondeterminism 
which confronts the attempts to enclose it in a single, preferably initial, model. This difficulty may be 
expressed by the slogan that ``choice is not a constructor.'' An occurrence 
of the syntactic operation $\ch$ in 
specifications will typically be reflected in the initial model by the occurrence of the respective choice 
terms, such as $a\ch b$. They, however, represent a kind of ``intuitive junk'' because choice is not supposed to 
introduce any new elements into the model. On the other hand, the intended meaning cannot be covered 
by the purely equational language, which corrupts the nature of the choice operator and reduces it to a 
deterministic function. 

The solution comes in some form of the ``is a possible result'' predicate. It is present in almost all 
approaches as inclusion, partial ordering or rewrite rules. In cases when the initial semantics can be 
obtained -- and these are the cases when the specifications are restricted 
to Horn theories -- such a predicate 
corresponds to the intuitive meaning of the nondeterministic operations. 

For multialgebras, the initial semantics can be obtained only in particular cases. To guarantee its 
general applicability one has to introduce some partial order models. Such models, however, are based on 
blurring the distinction between individuals and sets. In particular, they give the predicate ``is a possible 
result of'' a mathematically simpler, but intuitively less obvious, meaning than the set based models do. 

Loose semantics of nondeterminism has not received much attention. The restriction to Horn 
theories, even with the ``is a possible result'' predicate, have more undesirable consequences for such 
semantics than in the deterministic case. The general models of determinate specifications introduce junk 
(undenotable elements), but the behavior of the operations applied to such elements is still controlled by 
the axioms. This is no longer the case when we move to the nondeterministic specifications. The axioms 
$x\Incl x\ch y$ and $y\Incl x\ch y$ specify only the lower bound on the admitted nondeterminism of the choice operator. In 
the general power-set models, the interpretation of nondeterministic ground 
terms such as $0\ch 1$ will be 
allowed to return any imaginable (and unimaginable) results besides the two prescribed by such a 
specification. Thus junk will appear, so to speak, not only next to 
non-junk, but also in the middle of it. 
(This does not apply to the unified algebras where the interpretation of choice as join excludes such 
situations.)

The computational character of nondeterminism finds its natural expression in the operational 
models. At the syntactic level it is reflected in the fact that nondeterminate terms do not denote unique 
values, and consequently violate the requirements of referential transparency and substitutivity. This leads 
to an operational approach not only in the semantics, but also in the reasoning. With the exception of the 
rewriting logic, which is helped by an elegant, although sophisticated semantics, 
this indicates why one had 
to await completeness results of the proposed reasoning systems for so long. 
Also, such systems 
describe the result set of a term not by a single formula, but by a set 
of formulae -- one for each possible 
result. Hence, a deduction of the result set of a term requires derivations of all such formulae. The 
reasoning must not only consider the syntax of the formulae involved, but also ensure that all possible 
rules have been applied. This deficiency does not occur in the calculus 
from subsection~\ref{sub:nondet} 

With respect to the last point, as well as to the deficiencies of Horn-specifications, disjunctive axioms 
provide significant help. However, such axioms do not admit initial models and introduce a few extra 
complications in the reasoning systems.

An important issue that has not been addressed in this paper concerns
the notion of implementation of nondeterministic data types. The
reason for this omission is the almost complete absence of any
published results which, we suppose, reflects the absence of active
research in that area. \cite{c:53, c:93} begun to discuss this issue.
Among the more recent works, \cite{c:107, c:132} point in a new
direction: In the context of data refinement it seems necessary to
distinguish underspecification from nondeterministic operations by
relaxing the referential transparency requirement with respect to the
latter. (This relaxation corresponds to the restricted substitutivity
in the logic discussed in subsection~\ref{sub:nondet}.) Mere
underspecification excludes the possibility of verifying
implementations which naturally would be considered correct and
plausible  (for instance, of sets with underspecified, but determinisitc 
choice function  by sequences with
the $head$ function).

Although there already exists an extensive literature on various aspects of nondeterminism in an 
algebraic setting, it does not seem that the research has established some consensus similar to the one 
discernible in the classical specifications of deterministic data types. 
Such a consensus -- concerning not the 
best and only formalism, but the relative importance and applicability 
of different formalisms -- is 
probably needed before the questions about implementation and structured specification of 
nondeterministic data types can receive closer attention. 

\begin{thebibliography}{}

\bibitem[\protect\citeauthoryear{Aarts, Backhouse, Hoogendijk, Voermans, and
  van~der Woude}{Aarts et~al.}{1992}]{c:1}
\bibsc{Aarts,~C., Backhouse,~R., Hoogendijk,~P., Voermans,~E., and van der
  Woude, J.} \bibyear{1992}.
\newblock A relational theory of datatypes.
\newblock [draft available at
  URL = http://www.win.tue.nl/win/cs/wp/papers/papers.html].

\bibitem[\protect\citeauthoryear{Aceto, DeNicola, and Fantechi}{Aceto
  et~al.}{1986}]{c:2}
\bibsc{Aceto, L., DeNicola, R., and Fantechi, A.} \bibyear{1986}.
\newblock \bibemph{Testing Equivalencies for Event Structures}.
\newblock LNCS, vol.~280, Springer.

\bibitem[\protect\citeauthoryear{Apt}{Apt}{1984}]{c:3a}
\bibsc{Apt, K.} \bibyear{1984}.
\newblock Ten years of Hoare's logic: a survey. Part II: Nondeterminism.
\newblock \bibemphic{Theoretical Computer Science}~\bibemph{28}, 83--109.

\bibitem[\protect\citeauthoryear{Apt and Plotkin}{Apt and Plotkin}{1981}]{c:3}
\bibsc{Apt, K. and Plotkin, G.} \bibyear{1981}.
\newblock A Cook's tour of countable nondeterminism.
\newblock In \bibemphic{Automata, Languages and Programming, 8-th Colloquium}
  (1981). LNCS vol.~115, Springer.

\bibitem[\protect\citeauthoryear{Astesiano and Costa}{Astesiano and
  Costa}{1979}]{c:4}
\bibsc{Astesiano, E. and Costa, G.} \bibyear{1979}.
\newblock Sharing in nondeterminism.
\newblock In \bibemphic{Automata, Languages and Programming, 6-th Colloquium}
  (1979). LNCS, vol.~71, Springer.

\bibitem[\protect\citeauthoryear{Back}{Back}{1980}]{c:5}
\bibsc{Back, R.} \bibyear{1980}.
\newblock Semantics of unbounded nondeterminism.
\newblock In \bibemphic{Automata, Languages and Programming} (1980). LNCS,
  vol.~85, Springer.

\bibitem[\protect\citeauthoryear{Back and von Wright}{Back and von
  Wright}{1990}]{c:6}
\bibsc{Back, R. and von Wright, J.} \bibyear{1990}.
\newblock Duality in specification languages: A lattice-theoretical approach.
\newblock \bibemphic{Acta Informatica}~\bibemph{27}, 583--625.

\bibitem[\protect\citeauthoryear{Barr and Wells}{Barr and Wells}{1985}]{c:BarT}
\bibsc{Barr, M. and Wells, C.} \bibyear{1985}.
\newblock \bibemph{Toposes, Triples and Theories}.
\newblock Springer.

\bibitem[\protect\citeauthoryear{Barr and Wells}{Barr and Wells}{1990}]{c:Bar}
\bibsc{Barr, M. and Wells, C.} \bibyear{1990}.
\newblock \bibemph{Category Theory for Computing Science}.
\newblock Prentice Hall.

\bibitem[\protect\citeauthoryear{Bauer}{Bauer}{1985}]{c:8}
\bibsc{Bauer, F.} \bibyear{1985}.
\newblock \bibemph{The Munich Project CIP: The Wide Spectrum Language}.
\newblock LNCS, vol. 183, Springer.

\bibitem[\protect\citeauthoryear{Beki\u{c}}{Beki\u{c}}{1984}]{c:9}
\bibsc{Beki\u{c}, H.} \bibyear{1984}.
\newblock \bibemph{Programming Langugages and Their Definition}.
\newblock LNCS, vol.~177, Springer.

\bibitem[\protect\citeauthoryear{Ben-Ari, Manna, and Pnueli}{Ben-Ari
  et~al.}{1981}]{c:10}
\bibsc{Ben-Ari, M., Manna, Z., and Pnueli, A.} \bibyear{1981}.
\newblock The temporal logic of branching time.
\newblock In \bibemphic{8-th Annual Symposium on PoPL} (1981).

\bibitem[\protect\citeauthoryear{Bergstra and Klop}{Bergstra and
  Klop}{1983}]{c:11}
\bibsc{Bergstra, J. and Klop, J.} \bibyear{1983}.
\newblock An abstraction mechanism for process algebras.
\newblock Technical Report IW 231/83, Dept. of CS, Matematisch Centrum,
  Amsterdam.

\bibitem[\protect\citeauthoryear{Bergstra and Klop}{Bergstra and
  Klop}{1986}]{c:13}
\bibsc{Bergstra, J. and Klop, J.} \bibyear{1986}.
\newblock Algebra of communicating processes.
\newblock In \bibemphic{CWI Symposium on Mathematics and CS} (1986), pp.\
  89--138.

\bibitem[\protect\citeauthoryear{Bergstra and Tucker}{Bergstra and
  Tucker}{1983}]{c:12}
\bibsc{Bergstra, J. and Tucker, J.} \bibyear{1983}.
\newblock Initial and final algebra semantics for data type specifications.
\newblock \bibemphic{SIAM J. Computing}~\bibemph{12}, 366--387.

\bibitem[\protect\citeauthoryear{Bergstra and Tucker}{Bergstra and
  Tucker}{1987}]{c:14}
\bibsc{Bergstra, J. and Tucker, J.} \bibyear{1987}.
\newblock Algebraic specifications of computable and semicomputable data types.
\newblock \bibemphic{Theoretical Computer Science}~\bibemph{50}, 137--181.

\bibitem[\protect\citeauthoryear{Bia{\l}asik and Konikowska}{Bia{\l}asik and
  Konikowska}{1995}]{c:Bia1}
\bibsc{Bia{\l}asik, M. and Konikowska, B.} \bibyear{1995}.
\newblock Reasoning with nondeterministic specifications.
\newblock Technical Report 793, Polish Academy of Sciences, Institute of CS,
  Warsaw.

\bibitem[\protect\citeauthoryear{Bia{\l}asik and Konikowska}{Bia{\l}asik and
  Konikowska}{1996}]{c:Bia}
\bibsc{Bia{\l}asik, M. and Konikowska, B.} \bibyear{1996}.
\newblock A logic for nondeterministic specifications.
\newblock [to appear in ``Essays Dedicated to the Memory of H.Rasiowa'',
  Kluwer].

\bibitem[\protect\citeauthoryear{Bloom}{Bloom}{1976}]{c:Bloom}
\bibsc{Bloom, S.} \bibyear{1976}.
\newblock Varieties of ordered algebras.
\newblock \bibemphic{J. of Computer and System Sciences}~\bibemph{13},
  200--212.

\bibitem[\protect\citeauthoryear{Bloom and Tindell}{Bloom and
  Tindell}{1980}]{c:15}
\bibsc{Bloom, S. and Tindell, R.} \bibyear{1980}.
\newblock Compatible orderings on the metric theory of trees.
\newblock \bibemphic{SIAM J. Computing}~\bibemph{9},~4, 683--691.

\bibitem[\protect\citeauthoryear{Borceux}{Borceux}{1994}]{c:Bor}
\bibsc{Borceux, F.} \bibyear{1994}.
\newblock \bibemph{Handbook of Categorical Algebra}.
\newblock Cambridge.

\bibitem[\protect\citeauthoryear{Boudol}{Boudol}{1980}]{c:16}
\bibsc{Boudol, G.} \bibyear{1980}.
\newblock \bibemph{Calculus maximaux et semantique operationnelle des
  programmes non deterministes}.
\newblock Ph.\ D. thesis, University of Paris.

\bibitem[\protect\citeauthoryear{Broy}{Broy}{1983}]{c:22}
\bibsc{Broy, M.} \bibyear{1983}.
\newblock Fixed point theory for communication and concurrency.
\newblock In \bibemphic{IFIP TC2 Working Conference on Formal Description of
  Programming Concepts II} (1983), pp.\  125--147. North-Holland.

\bibitem[\protect\citeauthoryear{Broy}{Broy}{1984}]{c:23}
\bibsc{Broy, M.} \bibyear{1984}.
\newblock On the herbrand kleene universe for nondeterministic computations.
\newblock In \bibemphic{MFCS'84} (1984). LNCS vol.~176, Springer.

\bibitem[\protect\citeauthoryear{Broy}{Broy}{1986}]{c:24}
\bibsc{Broy, M.} \bibyear{1986}.
\newblock A theory for nondeterminism, parallelism, communication and
  concurrency.
\newblock \bibemphic{Theoretical Computer Science}~\bibemph{45}.

\bibitem[\protect\citeauthoryear{Broy, Dosch, Parsch, Pepper, and Wirsing}{Broy
  et~al.}{1979}]{c:17}
\bibsc{Broy, M., Dosch, W., Parsch, H., Pepper, P., and Wirsing, M.}
  \bibyear{1979}.
\newblock Existential quantifiers in abstract data types.
\newblock In \bibemphic{Automata, Languages and Programming, 6-th Colloquium}
  (1979). LNCS vol.~71, Springer.

\bibitem[\protect\citeauthoryear{Broy, Gnatz, and Wirsing}{Broy
  et~al.}{1980}]{c:18}
\bibsc{Broy, M., Gnatz, R., and Wirsing, M.} \bibyear{1980}.
\newblock \bibemph{Semantics of Nondeterministic and Noncontinuous Constructs},
  pp.\  553--392.
\newblock Springer.

\bibitem[\protect\citeauthoryear{Broy and Wirsing}{Broy and
  Wirsing}{1980}]{c:20}
\bibsc{Broy, M. and Wirsing, M.} \bibyear{1980}.
\newblock Programming languages as abstract data types.
\newblock In \bibemphic{Lille Colloque} (1980).

\bibitem[\protect\citeauthoryear{Broy and Wirsing}{Broy and
  Wirsing}{1981a}]{c:19}
\bibsc{Broy, M. and Wirsing, M.} \bibyear{1981a}.
\newblock Initial versus terminal algebra semantics for partially defined
  abstract types.
\newblock Technical Report TUM-I 8018 (December), Technische Universit\"{a}t
  M\"{u}nchen.

\bibitem[\protect\citeauthoryear{Broy and Wirsing}{Broy and
  Wirsing}{1981b}]{c:21}
\bibsc{Broy, M. and Wirsing, M.} \bibyear{1981b}.
\newblock On the algebraic specification of nondeterministic programming
  languages.
\newblock In \bibemphic{CAAP'81} (1981), pp.\  162--179. LNCS vol.~112,
  Springer.

\bibitem[\protect\citeauthoryear{Chandra}{Chandra}{1978}]{c:25}
\bibsc{Chandra, A.} \bibyear{1978}.
\newblock Computable nondeterministic functions.
\newblock In \bibemphic{Foundations of Computer Science, 19-th Annual
  Symposium} (1978).

\bibitem[\protect\citeauthoryear{Clinger}{Clinger}{1982}]{c:26}
\bibsc{Clinger, W.} \bibyear{1982}.
\newblock Nondeterministic call by need is neither lazy nor by name.
\newblock In \bibemphic{ACM Symposium on LISP and Functional Programming}
  (1982), pp.\  226--234.

\bibitem[\protect\citeauthoryear{Cohn}{Cohn}{1965}]{c:27}
\bibsc{Cohn, P.} \bibyear{1965}.
\newblock \bibemph{Universal Algebra, Mathematics and Its Applications, vol.6}.
\newblock D.Reidel Publishing Company.

\bibitem[\protect\citeauthoryear{Dahl}{Dahl}{1992}]{c:28}
\bibsc{Dahl, O.} \bibyear{1992}.
\newblock \bibemph{Verifiable Programming}.
\newblock Prentice Hall.

\bibitem[\protect\citeauthoryear{de~Bakker}{de~Bakker}{1976}]{c:7}
\bibsc{de~Bakker, J.} \bibyear{1976}.
\newblock Semantics and termination of nondeterministic recursive programs.
\newblock In \bibemphic{Automata Languages and Programming} (1976), pp.\
  435--477.

\bibitem[\protect\citeauthoryear{de~Liguro and Piperno}{de~Liguro and
  Piperno}{1992}]{c:73}
\bibsc{de~Liguro, U. and Piperno, A.} \bibyear{1992}.
\newblock Must pre-order in non-deterministic untyped lambda-calculus.
\newblock In \bibemphic{CAAP'92} (1992). LNCS vol.~581, Springer.

\bibitem[\protect\citeauthoryear{Dijkstra}{Dijkstra}{1975}]{c:29}
\bibsc{Dijkstra, E.} \bibyear{1975}.
\newblock Guarded commands, nondeterminacy and formal derivation of programs.
\newblock \bibemphic{CACM}~\bibemph{18}.

\bibitem[\protect\citeauthoryear{Dijkstra}{Dijkstra}{1976}]{c:30}
\bibsc{Dijkstra, E.} \bibyear{1976}.
\newblock \bibemph{A Discipline of Programming}.
\newblock Prentice Hall.

\bibitem[\protect\citeauthoryear{Dijkstra}{Dijkstra}{1984}]{c:31}
\bibsc{Dijkstra, E.} \bibyear{1984}.
\newblock \bibemph{A simple fix-point argument without the restriction to
  continuity}.
\newblock Springer.

\bibitem[\protect\citeauthoryear{Dovier, Omodeo, Pontelli, and Rossi}{Dovier
  et~al.}{1993}]{c:32}
\bibsc{Dovier, A., Omodeo, E., Pontelli, E., and Rossi, G.} \bibyear{1993}.
\newblock \bibemph{Embedding Finite Sets in a Logic Programming Language}, pp.\
   150--167.
\newblock Springer.

\bibitem[\protect\citeauthoryear{Egli}{Egli}{1975}]{c:33}
\bibsc{Egli, H.} \bibyear{1975}.
\newblock A mathematical model for nondeterministic computations.
\newblock Technical report, ETH.

\bibitem[\protect\citeauthoryear{Engelfriet and Schmidt}{Engelfriet and
  Schmidt}{1977}]{c:34}
\bibsc{Engelfriet, J. and Schmidt, E.} \bibyear{1977}.
\newblock IO and OI, 1.
\newblock \bibemphic{J. of Computer and System Sciences}~\bibemph{15},
  328--353.

\bibitem[\protect\citeauthoryear{Engelfriet and Schmidt}{Engelfriet and
  Schmidt}{1978}]{c:35}
\bibsc{Engelfriet, J. and Schmidt, E.} \bibyear{1978}.
\newblock IO and OI, 2.
\newblock \bibemphic{J. of Computer and System Sciences}~\bibemph{16}, 67--99.

\bibitem[\protect\citeauthoryear{Feldman and Harel}{Feldman and
  Harel}{1982}]{c:36}
\bibsc{Feldman, Y. and Harel, D.} \bibyear{1982}.
\newblock A probabilistic dynamic logic.
\newblock In \bibemphic{ACM Symposium on Theory of Computing, 14-th Annual
  Symposium} (1982).

\bibitem[\protect\citeauthoryear{Fern\'{a}ndez and Minker}{Fern\'{a}ndez and
  Minker}{1991}]{c:37}
\bibsc{Fern\'{a}ndez, J. and Minker, J.} \bibyear{1991}.
\newblock Bottom-up evaluation of hierarchical disjunctive deductive databases.
\newblock In \bibemphic{8-th International Conference on Logic Programming}
  (1991).

\bibitem[\protect\citeauthoryear{Floyd}{Floyd}{1967}]{c:38}
\bibsc{Floyd, R.} \bibyear{1967}.
\newblock Nondeterministic algorithms.
\newblock \bibemphic{Journal of the ACM}~\bibemph{14},~4.

\bibitem[\protect\citeauthoryear{Goguen}{Goguen}{1989}]{c:42}
\bibsc{Goguen, J.} \bibyear{1989}.
\newblock \bibemph{What is unification? A categorical view of substitution,
  equation, and solution}, pp.\  217--261.
\newblock Academic Press.

\bibitem[\protect\citeauthoryear{Goguen and Burstall}{Goguen and
  Burstall}{1983}]{c:41}
\bibsc{Goguen, J. and Burstall, R.} \bibyear{1983}.
\newblock \bibemph{Introducing Institutions}.
\newblock LNCS vol.~164, Springer.

\bibitem[\protect\citeauthoryear{Goguen, Thatcher, Wagner, and Wright}{Goguen
  et~al.}{1977}]{c:40}
\bibsc{Goguen, J., Thatcher, J., Wagner, E., and Wright, J.} \bibyear{1977}.
\newblock Initial algebra semantics and continuous algebras.
\newblock \bibemphic{Journal of ACM}~\bibemph{24}, 68--95.

\bibitem[\protect\citeauthoryear{Guessarian}{Guessarian}{1981}]{c:43}
\bibsc{Guessarian, I.} \bibyear{1981}.
\newblock \bibemph{Algebraic Semantics}.
\newblock LNCS vol.~99, Springer.

\bibitem[\protect\citeauthoryear{Guttag}{Guttag}{1975}]{c:44}
\bibsc{Guttag, J.} \bibyear{1975}.
\newblock The specification and application to programming of adt.
\newblock Technical Report CSR6-59, Computer Systems Research Group, University
  of Toronto.

\bibitem[\protect\citeauthoryear{Hansoul}{Hansoul}{1983}]{c:45}
\bibsc{Hansoul, G.} \bibyear{1983}.
\newblock A subdirect decomposition theorem for multialgebras.
\newblock \bibemphic{Algebra Universalis}~\bibemph{16}.

\bibitem[\protect\citeauthoryear{Harel, Meyer, and Pratt}{Harel
  et~al.}{1977}]{c:46}
\bibsc{Harel, D., Meyer, A., and Pratt, V.} \bibyear{1977}.
\newblock Computability and completeness in logics of programs.
\newblock In \bibemphic{9-th Annual ACM Symposium on Theory of Computing}
  (1977).

\bibitem[\protect\citeauthoryear{Harel and Pratt}{Harel and Pratt}{1978}]{c:47}
\bibsc{Harel, D. and Pratt, V.} \bibyear{1978}.
\newblock Nondeterminism in logics of programs.
\newblock In \bibemphic{5-th Annual Symposium on PoPL} (1978).

\bibitem[\protect\citeauthoryear{Heckmann}{Heckmann}{1992}]{c:48}
\bibsc{Heckmann, R.} \bibyear{1992}.
\newblock Power domains supporting recursion and failure.
\newblock In \bibemphic{CAAP'92} (1992). LNCS vol.~581, Springer.

\bibitem[\protect\citeauthoryear{Hennessy}{Hennessy}{1980}]{c:50}
\bibsc{Hennessy, M.} \bibyear{1980}.
\newblock On observing nondeterminism and concurrency.
\newblock In \bibemphic{Automata, Languages and Programming} (1980). LNCS
  vol.~85, Springer.

\bibitem[\protect\citeauthoryear{Hennessy}{Hennessy}{1982}]{c:51}
\bibsc{Hennessy, M.} \bibyear{1982}.
\newblock Powerdomains and nondeterministic recursive functions.
\newblock In \bibemphic{5-th International Symposium on Programming} (1982).
  LNCS vol.~137, Springer.

\bibitem[\protect\citeauthoryear{Hennessy}{Hennessy}{1988}]{c:52}
\bibsc{Hennessy, M.} \bibyear{1988}.
\newblock \bibemph{Observing processes}.
\newblock LNCS vol.~354, Springer.

\bibitem[\protect\citeauthoryear{Hennessy and Milner}{Hennessy and
  Milner}{1980}]{c:49}
\bibsc{Hennessy, M. and Milner, R.} \bibyear{1980}.
\newblock The semantics of call-by-value and call-by-name in a nondeterministic
  environment.
\newblock \bibemphic{SIAM J. Computing}~\bibemph{9},~1.

\bibitem[\protect\citeauthoryear{Hesselink}{Hesselink}{1988}]{c:53}
\bibsc{Hesselink, W.} \bibyear{1988}.
\newblock A mathematical approach to nondeterminism in data types.
\newblock \bibemphic{ACM ToPLaS}~\bibemph{10}.

\bibitem[\protect\citeauthoryear{Hesselink}{Hesselink}{1992}]{c:Hes}
\bibsc{Hesselink, W.} \bibyear{1992}.
\newblock \bibemph{Programs, Recursion and Unbounded Choice}.
\newblock Cambridge.

\bibitem[\protect\citeauthoryear{Hoare}{Hoare}{1985}]{c:54}
\bibsc{Hoare, C.} \bibyear{1985}.
\newblock \bibemph{Communicating Sequential Processes}.
\newblock Prentice Hall.

\bibitem[\protect\citeauthoryear{Hoogendik}{Hoogendik}{1992}]{c:55}
\bibsc{Hoogendik, P.} \bibyear{1992}.
\newblock Relational programming laws in boom hierarchy of types.
\newblock In \bibemphic{Mathematics of Program Construction} (1992). Springer.

\bibitem[\protect\citeauthoryear{Hornung and Raulefs}{Hornung and
  Raulefs}{1980}]{c:56}
\bibsc{Hornung, G. and Raulefs, P.} \bibyear{1980}.
\newblock Terminal algebra semantics and retractions for abstract data types.
\newblock In \bibemphic{Automata, Languages and Programming} (1980). LNCS
  vol.~85, Springer.

\bibitem[\protect\citeauthoryear{Huet and Hullot}{Huet and Hullot}{1981}]{c:60}
\bibsc{Huet, G. and Hullot, J.} \bibyear{1981}.
\newblock Proofs by induction in equational theories with constructors.
\newblock \bibemphic{J. of Computer and System Sciences}~\bibemph{25},
  239--266.

\bibitem[\protect\citeauthoryear{Hu{\ss}mann}{Hu{\ss}mann}{1988}]{c:57}
\bibsc{Hu{\ss}mann, H.} \bibyear{1988}.
\newblock Nondeterministic algebraic specifications and nonconfluent term
  rewriting.
\newblock In \bibemphic{Algebraic and Logic Programming} (1988). LNCS vol.~343,
  Springer.

\bibitem[\protect\citeauthoryear{Hu{\ss}mann}{Hu{\ss}mann}{1990}]{c:58}
\bibsc{Hu{\ss}mann, H.} \bibyear{1990}.
\newblock \bibemph{Nondeterministic algebraic specifications}.
\newblock Ph.\ D. thesis, Fak. f. Mathematik und Informatik, Universit\"{a}t
  Passau.

\bibitem[\protect\citeauthoryear{Hu{\ss}mann}{Hu{\ss}mann}{1993}]{c:59}
\bibsc{Hu{\ss}mann, H.} \bibyear{1993}.
\newblock \bibemph{Nondeterminism in Algebraic Specifications and Algebraic
  Programs}.
\newblock Birkh\"{a}user.
\newblock revised version of c:58.

\bibitem[\protect\citeauthoryear{Jayaraman}{Jayaraman}{1992}]{c:61}
\bibsc{Jayaraman, B.} \bibyear{1992}.
\newblock Implementation of subset-equational programs.
\newblock \bibemphic{J. of Logic Programming}~\bibemph{12},~4, 299--324.

\bibitem[\protect\citeauthoryear{Kaplan}{Kaplan}{1987}]{c:62}
\bibsc{Kaplan, S.} \bibyear{1987}.
\newblock \bibemph{Conditional Rewriting}.
\newblock LNCS vol.~308, Springer.

\bibitem[\protect\citeauthoryear{Kaplan}{Kaplan}{1988}]{c:63}
\bibsc{Kaplan, S.} \bibyear{1988}.
\newblock Rewriting with a nondeterministic choice operator.
\newblock \bibemphic{Theoretical Computer Science}~\bibemph{56}, 37--57.

\bibitem[\protect\citeauthoryear{Kapur}{Kapur}{1980}]{c:64}
\bibsc{Kapur, D.} \bibyear{1980}.
\newblock \bibemph{Towards a Theory of Abstract Data Types}.
\newblock Ph.\ D. thesis, Laboratory for CS, MIT.

\bibitem[\protect\citeauthoryear{Kennaway and Hoare}{Kennaway and
  Hoare}{1980}]{c:65}
\bibsc{Kennaway, J. and Hoare, C.} \bibyear{1980}.
\newblock A theory of nondeterminism.
\newblock In \bibemphic{Automata, Languages and Programming} (1980). LNCS
  vol.~85, Springer.

\bibitem[\protect\citeauthoryear{Kosinski}{Kosinski}{1978}]{c:66}
\bibsc{Kosinski, P.} \bibyear{1978}.
\newblock A straightforward denotational semantics for non-determinate data
  flow programs.
\newblock In \bibemphic{5-th Annual Symposium on PoPL} (1978).

\bibitem[\protect\citeauthoryear{Kosinski}{Kosinski}{1979}]{c:67}
\bibsc{Kosinski, P.} \bibyear{1979}.
\newblock \bibemph{Denotational Semantics of Determinate and Non-determinate
  Data Flow Programs}.
\newblock Ph.\ D. thesis, Laboratory of CS, MIT.

\bibitem[\protect\citeauthoryear{Kozen}{Kozen}{1981}]{c:68}
\bibsc{Kozen, D.} \bibyear{1981}.
\newblock Semantics of probabilistic programs.
\newblock \bibemphic{J. of Computer and System Sciences}~\bibemph{22}.

\bibitem[\protect\citeauthoryear{Kriau\u{c}iukas and Walicki}{Kriau\u{c}iukas
  and Walicki}{1995}]{c:69}
\bibsc{Kriau\u{c}iukas, V. and Walicki, M.} \bibyear{1995}.
\newblock Reasoning and rewriting with set-relations i: ground case.
\newblock In \bibemphic{CSL'94} (1995). LNCS vol.~933.

\bibitem[\protect\citeauthoryear{Kriau\u{c}iukas and Walicki}{Kriau\u{c}iukas
  and Walicki}{1996}]{c:69a}
\bibsc{Kriau\u{c}iukas, V. and Walicki, M.} \bibyear{1996}.
\newblock \bibemph{Reasoning and rewriting with set-relations II: the
  non-ground case}.
\newblock LNCS vol.~1130, Springer.

\bibitem[\protect\citeauthoryear{Kuiper}{Kuiper}{1981}]{c:70}
\bibsc{Kuiper, R.} \bibyear{1981}.
\newblock An operational semantics for bounded nondeterminism equivalent to a
  denotational one.
\newblock In \bibemphic{International Symposium on Algorithmic Languages}
  (1981), pp.\  373--398. North-Holland.

\bibitem[\protect\citeauthoryear{Lehmann and Rabin}{Lehmann and
  Rabin}{1981}]{c:LR}
\bibsc{Lehmann, D. and Rabin, M.} \bibyear{1981}.
\newblock On the advantages of free choice.
\newblock In \bibemphic{8-th Annual Symposium on PoPL} (1981).

\bibitem[\protect\citeauthoryear{Lehmann and Shelah}{Lehmann and
  Shelah}{1983}]{c:71}
\bibsc{Lehmann, D. and Shelah, S.} \bibyear{1983}.
\newblock Reasoning with time and chance.
\newblock In \bibemphic{Automata, Languages and Programming} (1983). LNCS
  vol.~154, Springer.

\bibitem[\protect\citeauthoryear{Levy and Augusti}{Levy and
  Augusti}{1993}]{c:72}
\bibsc{Levy, J. and Augusti, J.} \bibyear{1993}.
\newblock Bi-rewriting, a term rewriting technique for monotonic order
  relations.
\newblock In \bibemphic{RTA'93} (1993), pp.\  17--31. LNCS vol.~690, Springer.

\bibitem[\protect\citeauthoryear{Lyndon}{Lyndon}{1959}]{c:74}
\bibsc{Lyndon, R.} \bibyear{1959}.
\newblock Properties preserved under homomorphisms.
\newblock \bibemphic{Pacific J. of Mathematics}~\bibemph{9}.

\bibitem[\protect\citeauthoryear{MacLane}{MacLane}{1971}]{c:Mac}
\bibsc{MacLane, S.} \bibyear{1971}.
\newblock \bibemph{Categories for the Working Mathematician}.
\newblock Springer.

\bibitem[\protect\citeauthoryear{Mahr and Makowsky}{Mahr and
  Makowsky}{1983}]{c:76}
\bibsc{Mahr, B. and Makowsky, J.} \bibyear{1983}.
\newblock Characterizing specification languages which admit initial semantics.
\newblock In \bibemphic{CAAP'93} (1983), pp.\  300--316. LNCS vol.~159,
  Springer.

\bibitem[\protect\citeauthoryear{Maibaum}{Maibaum}{1977}]{c:77}
\bibsc{Maibaum, T.} \bibyear{1977}.
\newblock The semantics of nondeterminism.
\newblock Technical Report CS-77-30 (December), University of Waterloo,
  Ontario, Canada.

\bibitem[\protect\citeauthoryear{Makowsky}{Makowsky}{1987}]{c:78}
\bibsc{Makowsky, J.} \bibyear{1987}.
\newblock Why horn formulas matter in computer science.
\newblock \bibemphic{J. of Computer and System Sciences}~\bibemph{34}.

\bibitem[\protect\citeauthoryear{Mal'cev}{Mal'cev}{1971}]{c:79}
\bibsc{Mal'cev, A.} \bibyear{1971}.
\newblock \bibemph{The Metamathematics of Algebraic Systems}.
\newblock North-Holland.
\newblock [series: Studies in Logic and the Foundations of Mathematics, vol.
  66].

\bibitem[\protect\citeauthoryear{Mal'cev}{Mal'cev}{1973}]{c:80}
\bibsc{Mal'cev, A.} \bibyear{1973}.
\newblock \bibemph{Algebraic Systems}.
\newblock Springer.
\newblock [series: Die Grundlehren der mathematischen Wissenschaften in
  Einzeldarstellungen, vol. 192].

\bibitem[\protect\citeauthoryear{Manes}{Manes}{1982}]{c:81}
\bibsc{Manes, A.} \bibyear{1982}.
\newblock Fuzzy theories.
\newblock \bibemphic{J. of Mathematical Analysis and Applications}.

\bibitem[\protect\citeauthoryear{Manna}{Manna}{1970}]{c:82}
\bibsc{Manna, Z.} \bibyear{1970}.
\newblock The correctness of nondeterministic programs.
\newblock \bibemphic{Artificial Intelligence}~\bibemph{1}, 1--26.

\bibitem[\protect\citeauthoryear{Manna and Pnueli}{Manna and
  Pnueli}{1992}]{c:83}
\bibsc{Manna, Z. and Pnueli, A.} \bibyear{1992}.
\newblock \bibemph{The Temporal Logic of Reactive and Concurrent Systems}.
\newblock Springer.

\bibitem[\protect\citeauthoryear{McCarthy}{McCarthy}{1963}]{c:84}
\bibsc{McCarthy, J.} \bibyear{1963}.
\newblock \bibemph{A basis for mathematical theory of computation}.
\newblock North-Holland.

\bibitem[\protect\citeauthoryear{Meldal}{Meldal}{1989}]{c:85}
\bibsc{Meldal, S.} \bibyear{1989}.
\newblock An abstract axiomatization of pointer types.
\newblock In \bibemphic{22-nd Annual Hawaii International Conference on System
  Sciences} (1989). IEEE Computer Society Press.

\bibitem[\protect\citeauthoryear{Meseguer}{Meseguer}{1983}]{c:Mes}
\bibsc{Meseguer, J.} \bibyear{1983}.
\newblock Order completion monads.
\newblock \bibemphic{Algebra Universalis}~\bibemph{16}, 63--82.

\bibitem[\protect\citeauthoryear{Meseguer}{Meseguer}{1990}]{c:86}
\bibsc{Meseguer, J.} \bibyear{1990}.
\newblock A logical theory of concurrent objects.
\newblock In \bibemphic{OOPSLA ECOOP'90} (1990), pp.\  101--115. SIGPLAN
  Notices, vol. 25 (10).

\bibitem[\protect\citeauthoryear{Meseguer}{Meseguer}{1992}]{c:87}
\bibsc{Meseguer, J.} \bibyear{1992}.
\newblock Conditional rewriting logic as a unified model of concurrency.
\newblock \bibemphic{Theoretical Computr Science}~\bibemph{96}, 73--155.

\bibitem[\protect\citeauthoryear{Mezei and Wright}{Mezei and
  Wright}{1967}]{c:88}
\bibsc{Mezei, J. and Wright, J.} \bibyear{1967}.
\newblock Algebraic automata and context-free sets.
\newblock \bibemphic{Information and Control}~\bibemph{11}.

\bibitem[\protect\citeauthoryear{Milner}{Milner}{1973}]{c:89}
\bibsc{Milner, R.} \bibyear{1973}.
\newblock Processes: a mathematical model of computing agents.
\newblock In \bibemphic{Logic Colloquium} (1973).

\bibitem[\protect\citeauthoryear{Milner}{Milner}{1980}]{c:90}
\bibsc{Milner, R.} \bibyear{1980}.
\newblock \bibemph{Calculi of Communicating Systems}.
\newblock LNCS vol.~92, Springer.

\bibitem[\protect\citeauthoryear{Milner}{Milner}{1982}]{c:101a}
\bibsc{Milner, R.} \bibyear{1982}.
\newblock \bibemph{Communication and Concurrency}.
\newblock Prentice Hall.

\bibitem[\protect\citeauthoryear{M\"{o}ller}{M\"{o}ller}{1985}]{c:75}
\bibsc{M\"{o}ller, B.} \bibyear{1985}.
\newblock On the algebraic specification of infinite objects -- ordered and
  continuous models of algebraic types.
\newblock \bibemphic{Acta Informatica}~\bibemph{22}, 537--578.

\bibitem[\protect\citeauthoryear{Mosses}{Mosses}{1989a}]{c:92}
\bibsc{Mosses, P.} \bibyear{1989a}.
\newblock Unified algebras and action semantics.
\newblock In \bibemphic{STACS'89} (1989). LNCS vol.~349, Springer.

\bibitem[\protect\citeauthoryear{Mosses}{Mosses}{1989b}]{c:91}
\bibsc{Mosses, P.} \bibyear{1989b}.
\newblock Unified algebras and institutions.
\newblock In \bibemphic{LICS'89, 4-th Annual Symposium} (1989).

\bibitem[\protect\citeauthoryear{Nelson}{Nelson}{1992}]{c:Nel}
\bibsc{Nelson, G.} \bibyear{1992}.
\newblock A generalization of dijkstra's calculus.
\newblock \bibemphic{ACM ToPLaS}~\bibemph{11}, 517--561.

\bibitem[\protect\citeauthoryear{Nipkow}{Nipkow}{1986}]{c:93}
\bibsc{Nipkow, T.} \bibyear{1986}.
\newblock Non-deterministic data types: models and implementations.
\newblock \bibemphic{Acta Informatica}~\bibemph{22}, 629--661.

\bibitem[\protect\citeauthoryear{Nipkow}{Nipkow}{1987a}]{c:95}
\bibsc{Nipkow, T.} \bibyear{1987a}.
\newblock \bibemph{Behavioural Implementations Concepts for Non-deterministic
  Data Types}.
\newblock Ph.\ D. thesis, Dept. of CS, University of Manchester.

\bibitem[\protect\citeauthoryear{Nipkow}{Nipkow}{1987b}]{c:94}
\bibsc{Nipkow, T.} \bibyear{1987b}.
\newblock \bibemph{Observing non-deterministic data types}.
\newblock LNCS vol.~332, Springer.

\bibitem[\protect\citeauthoryear{Nivat}{Nivat}{1975}]{c:96}
\bibsc{Nivat, M.} \bibyear{1975}.
\newblock On the interpretation of polyadic program schemes.
\newblock \bibemphic{Symposia Mathematica}~\bibemph{15}, 255--281.

\bibitem[\protect\citeauthoryear{Nivat}{Nivat}{1980}]{c:97}
\bibsc{Nivat, M.} \bibyear{1980}.
\newblock Nondeterministic programs: an algebraic overview.
\newblock In \bibemphic{Information Processing '80} (1980). North-Holland.

\bibitem[\protect\citeauthoryear{O'Donnell}{O'Donnell}{1977}]{c:98}
\bibsc{O'Donnell, M.} \bibyear{1977}.
\newblock \bibemph{Computing in Systems Described by Equations}.
\newblock LNCS vol.~58, Springer.

\bibitem[\protect\citeauthoryear{Park}{Park}{1979}]{c:99}
\bibsc{Park, D.} \bibyear{1979}.
\newblock \bibemph{On the semantics of fair parallellism}.
\newblock LNCS vol.~86, Springer.

\bibitem[\protect\citeauthoryear{Petri}{Petri}{1977}]{c:100}
\bibsc{Petri, C.} \bibyear{1977}.
\newblock Non-sequential pocesses.
\newblock Technical Report ISF-77-05, Gesellschaft f. Mathematik und
  Datenverarbeitung, Sankt Augustin.

\bibitem[\protect\citeauthoryear{Pickert}{Pickert}{1950}]{c:101}
\bibsc{Pickert, G.} \bibyear{1950}.
\newblock Bemerkungen zum homomorphie-begriff.
\newblock \bibemphic{Mathematische Zeitschrift}~\bibemph{53}.

\bibitem[\protect\citeauthoryear{Pickett}{Pickett}{1967}]{c:102}
\bibsc{Pickett, H.} \bibyear{1967}.
\newblock Homomorphisms and subalgebras of multialgebras.
\newblock \bibemphic{Pacific J. of Mathematics}~\bibemph{21}, 327--342.

\bibitem[\protect\citeauthoryear{Plotkin}{Plotkin}{1976}]{c:103}
\bibsc{Plotkin, G.} \bibyear{1976}.
\newblock A power domain construction.
\newblock \bibemphic{SIAM J. Computing}~\bibemph{5},~3, 452--487.

\bibitem[\protect\citeauthoryear{Plotkin}{Plotkin}{1980}]{c:104}
\bibsc{Plotkin, G.} \bibyear{1980}.
\newblock \bibemph{Dijkstra's predicate transformers and Smyth's powerdomains}.
\newblock LNCS vol.~86, Springer.

\bibitem[\protect\citeauthoryear{Plotkin}{Plotkin}{1982}]{c:106}
\bibsc{Plotkin,~G.}~\bibyear{1982}.
\newblock Domains.
\newblock [lecture notes, available at
  URL = http://hypatia.dcs.qmw.ac.uk/authors/P/PlotkinGD/papers/dom.ps.Z].

\bibitem[\protect\citeauthoryear{Plotkin and Apt}{Plotkin and Apt}{}]{c:105}
\bibsc{Plotkin, G. and Apt, K.}
\newblock Countable nondeterminism and random assignment.
\newblock \bibemphic{J. of the ACM}~\bibemph{33},~4, 724--767.

\bibitem[\protect\citeauthoryear{Qian and Goldberg}{Qian and
  Goldberg}{1993}]{c:107}
\bibsc{Qian, X. and Goldberg, A.} \bibyear{1993}.
\newblock Referntial opacity in nondeterministic data refinement.
\newblock \bibemphic{ACM LoPLaS}~\bibemph{2},~1-4, 233--241.

\bibitem[\protect\citeauthoryear{Reif}{Reif}{1980}]{c:108}
\bibsc{Reif, J.} \bibyear{1980}.
\newblock Logics for probabilistic programming.
\newblock In \bibemphic{Theory of Computing, 12-th ACM Symposium} (1980).

\bibitem[\protect\citeauthoryear{Reisig}{Reisig}{1985}]{c:109}
\bibsc{Reisig, W.} \bibyear{1985}.
\newblock \bibemph{Petri Nets. An Introduction}.
\newblock Springer.
\newblock [EATCS Monographs on Theoretical Computer Science, vol. 4].

\bibitem[\protect\citeauthoryear{Saheb-Djahromi}{Saheb-Djahromi}{1979}]{c:111}
\bibsc{Saheb-Djahromi, N.} \bibyear{1979}.
\newblock Probabilisitic cpo's for nondetrerminism.
\newblock Technical Report CSR-37-79, Dept. of CS, University of Edinburgh.

\bibitem[\protect\citeauthoryear{Sannella and Tarlecki}{Sannella and
  Tarlecki}{1988}]{c:112}
\bibsc{Sannella, D. and Tarlecki, A.} \bibyear{1988}.
\newblock Specifications in arbitrary institutions.
\newblock \bibemphic{Information and Computation}~\bibemph{76}, 165--210.

\bibitem[\protect\citeauthoryear{Schwartz, Dewar, Schonberg, and
  Dubinsky}{Schwartz et~al.}{1986}]{c:114}
\bibsc{Schwartz, J., Dewar, R., Schonberg, E., and Dubinsky, E.}
  \bibyear{1986}.
\newblock \bibemph{Programming with Sets; An Introduction to SETL}.
\newblock Springer.

\bibitem[\protect\citeauthoryear{Schwartz}{Schwartz}{1979}]{c:113}
\bibsc{Schwartz, R.} \bibyear{1979}.
\newblock An axiomatic treatement of algol 68 routines.
\newblock In \bibemphic{Automata, Languages and Programming, 6-th Colloquium}
  (1979). LNCS vol.~71, Springer.

\bibitem[\protect\citeauthoryear{Scott}{Scott}{1972}]{c:115}
\bibsc{Scott, D.} \bibyear{1972}.
\newblock Continuous lattices.
\newblock In \bibemphic{Dalhousie Conference 1971} (1972). LNM vol.~274,
  Springer.

\bibitem[\protect\citeauthoryear{Scott}{Scott}{1976}]{c:116}
\bibsc{Scott, D.} \bibyear{1976}.
\newblock Data types as lattices.
\newblock \bibemphic{SIAM J. Computing}~\bibemph{5},~4, 522--587.

\bibitem[\protect\citeauthoryear{Smyth}{Smyth}{1978}]{c:117}
\bibsc{Smyth, M.} \bibyear{1978}.
\newblock Power domains.
\newblock \bibemphic{J. of Computer and System Sciences}~\bibemph{16}.

\bibitem[\protect\citeauthoryear{Smyth}{Smyth}{1983}]{c:118}
\bibsc{Smyth, M.} \bibyear{1983}.
\newblock Power domains and predicate transformers: a topological view.
\newblock In \bibemphic{Automata, Languages and Programming} (1983), pp.\
  225--241. LNCS vol.~154, Springer.

\bibitem[\protect\citeauthoryear{S{\o}ndergaard and Sestoft}{S{\o}ndergaard and
  Sestoft}{1992}]{c:110}
\bibsc{S{\o}ndergaard, H. and Sestoft, P.} \bibyear{1992}.
\newblock Non-determinism in functional languages.
\newblock \bibemphic{Computer Journal}~\bibemph{35},~5, 514--523.

\bibitem[\protect\citeauthoryear{Spitzen and Wegbreit}{Spitzen and
  Wegbreit}{1975}]{c:genind}
\bibsc{Spitzen, J. and Wegbreit, B.} \bibyear{1975}.
\newblock The verification and synthesis of data structures.
\newblock \bibemphic{Acta Informatica}~\bibemph{4}, 127--144.

\bibitem[\protect\citeauthoryear{Stark}{Stark}{1989}]{c:119}
\bibsc{Stark, E.} \bibyear{1989}.
\newblock Compositional relational semantics for indeterminate dataflow
  networks.
\newblock In \bibemphic{Category Theory and Computer Science} (1989). LNCS
  vol.~389, Springer.

\bibitem[\protect\citeauthoryear{Stolzenburg}{Stolzenburg}{1993}]{c:120}
\bibsc{Stolzenburg, F.} \bibyear{1993}.
\newblock An algorithm for general set unification.
\newblock In \bibemphic{Workshop on Logic Programming with Sets, ICLP'93}
  (1993).

\bibitem[\protect\citeauthoryear{Subrahmanyam}{Subrahmanyam}{1981}]{c:121}
\bibsc{Subrahmanyam, P.} \bibyear{1981}.
\newblock Nondeterminism in abstract data types.
\newblock In \bibemphic{Automata, Languages and Programming} (1981). LNCS
  vol.~115, Springer.

\bibitem[\protect\citeauthoryear{Tarlecki}{Tarlecki}{1984}]{c:122}
\bibsc{Tarlecki, A.} \bibyear{1984}.
\newblock Free constructions in algebraic institutions.
\newblock In \bibemphic{MFCS'84} (1984). LNCS vol.~176, Springer.

\bibitem[\protect\citeauthoryear{van Glabbeek}{van Glabbeek}{1987}]{c:39}
\bibsc{van Glabbeek, R.} \bibyear{1987}.
\newblock Bounded nondeterminism and the approximation induction principle in
  process algebra.
\newblock In \bibemphic{STACS'87} (1987), pp.\  336--347. LNCS vol.~247,
  Springer.

\bibitem[\protect\citeauthoryear{Voermans}{Voermans}{1991}]{c:123}
\bibsc{Voermans, E.} \bibyear{1991}.
\newblock Pers as types, inductive types and types with laws.
\newblock In \bibemphic{PHOENIX Seminar and Workshop on Declarative
  Programming} (1991). Springer.

\bibitem[\protect\citeauthoryear{Volger}{Volger}{1989a}]{c:124}
\bibsc{Volger, H.} \bibyear{1989a}.
\newblock The semantics of disjunctive deductive databases.
\newblock Technical Report MIP-8931 (October), Fak. f. Mathematik und
  Informatik, Universit\"{a}t Passau.

\bibitem[\protect\citeauthoryear{Volger}{Volger}{1989b}]{c:125}
\bibsc{Volger, H.} \bibyear{1989b}.
\newblock The semantics of disjunctive deductive databases.
\newblock In \bibemphic{CSL'89} (1989). LNCS vol.~440, Springer.

\bibitem[\protect\citeauthoryear{Walicki}{Walicki}{1993}]{c:127}
\bibsc{Walicki, M.} \bibyear{1993}.
\newblock \bibemph{Algebraic Specifications of Nondeterminism}.
\newblock Ph.\ D. thesis, Dept. of Informatics, University of Bergen.

\bibitem[\protect\citeauthoryear{Walicki and Broy}{Walicki and
  Broy}{1995}]{c:132}
\bibsc{Walicki, M. and Broy, M.} \bibyear{1995}.
\newblock Structured specifications and implementation of nondeterministic data
  types.
\newblock \bibemphic{Nordic Journal of Computing}~\bibemph{2}, 358--395.

\bibitem[\protect\citeauthoryear{Walicki and Meldal}{Walicki and
  Meldal}{1993a}]{c:128}
\bibsc{Walicki, M. and Meldal, S.} \bibyear{1993a}.
\newblock Initiality + nondeterminism $\impl$ junk.
\newblock In \bibemphic{NIK'93} (1993). Tapir.

\bibitem[\protect\citeauthoryear{Walicki and Meldal}{Walicki and
  Meldal}{1993b}]{c:129}
\bibsc{Walicki, M. and Meldal, S.} \bibyear{1993b}.
\newblock Sets and nondeterminism.
\newblock In \bibemphic{Workshop on Logic Programming with Sets, ICLP'93}
  (1993).

\bibitem[\protect\citeauthoryear{Walicki and Meldal}{Walicki and
  Meldal}{1995a}]{c:126}
\bibsc{Walicki, M. and Meldal, S.} \bibyear{1995a}.
\newblock A complete calculus for the multialgebraic and functional semantics
  of nondeterminism.
\newblock \bibemphic{ACM ToPLaS}~\bibemph{17},~2.

\bibitem[\protect\citeauthoryear{Walicki and Meldal}{Walicki and
  Meldal}{1995b}]{c:133}
\bibsc{Walicki, M. and Meldal, S.} \bibyear{1995b}.
\newblock Generated models and the omega-rule: the nondeterministic case.
\newblock In \bibemphic{TAPSOFT'95} (1995). LNCS vol.~915, Springer.

\bibitem[\protect\citeauthoryear{Walicki and Meldal}{Walicki and
  Meldal}{1995c}]{c:130}
\bibsc{Walicki, M. and Meldal, S.} \bibyear{1995c}.
\newblock \bibemph{Multialgebras, power algebras and complete calculi of
  identities and inclusions}.
\newblock LNCS vol.~906, Springer.

\bibitem[\protect\citeauthoryear{Winskel}{Winskel}{1982}]{c:134}
\bibsc{Winskel, G.} \bibyear{1982}.
\newblock Event structure semantics of ccs and related languages.
\newblock In \bibemphic{ICALP'82} (1982). LNCS vol.~140, Springer.

\bibitem[\protect\citeauthoryear{Winskel}{Winskel}{1987}]{c:135}
\bibsc{Winskel, G.} \bibyear{1987}.
\newblock \bibemph{Event Structures}.
\newblock LNCS vol.~255, Springer.

\bibitem[\protect\citeauthoryear{Winskel}{Winskel}{1988}]{c:136}
\bibsc{Winskel, G.} \bibyear{1988}.
\newblock \bibemph{An Introduction to Event Structures}.
\newblock LNCS vol.~354, Springer.

\bibitem[\protect\citeauthoryear{Wolter and L\"{o}we}{Wolter and
  L\"{o}we}{1992}]{c:137}
\bibsc{Wolter, U. and L\"{o}we, M.} \bibyear{1992}.
\newblock Beyond conditional equations.
\newblock In \bibemphic{CAAP'92} (1992). LNCS vol.~581, Springer.

\end{thebibliography}

\end{document}


