% Copyright 1988 by Sriram Sankar.
%
% Language extensions to Ada are delimited by %begin LANGUAGE and
% %end LANGUAGE.
%
% GLOBAL DEFINITIONS:
%
% The fonts for the keywords.
\def\apekeywordfont{\large\bf}%
\def\apkeywordfont{\normalsize\bf}%
% The fonts for comments.
\def\apecommentfont{\normalsize\sl}%
\def\apcommentfont{\normalsize\sl}%
% The default fonts for everything else.
\def\apebodyfont{\small\rm}%
\def\apbodyfont{\small\rm}%
% The space generated by the <space> character.
\def\apehspace{0.65em}%
\def\aphspace{0.5em}%
% The space inserted between each line.
\def\apevspace{0pt}%
% The space left at the beginning of each line.
\def\apelmargin{0pt}%
%
% The above ten macro definitions can be redefined within the document as many
% times as desired.  The default settings above are in terms of LaTeX macros
% (e.g. \large, \small, etc.).  Note: These are the only LaTeX dependencies in
% this file.
%
\catcode`\!=11%
\catcode`\^^I=9%
% Tabs will now be ignored, so they can be used to format the macros below.
%
% The following macros are for formatting the Ada keywords.  Note that they
% accept the keyword as an argument in LOWER-CASE.  To format keywords in other
% ways (e.g. upper-case), one could either change the case of these keyword
% arguments below, or define \apekeywordfont is such a way that it changes the
% case of its argument appropriately.
%
\def\!keyword{\apkeywordfont}%
%
\def\Abort{{\!keyword{abort}}}%
\def\Abs{{\!keyword{abs}}}%
\def\Accept{{\!keyword{accept}}}%
\def\Access{{\!keyword{access}}}%
\def\All{{\!keyword{all}}}%
\def\And{{\!keyword{and}}}%
\def\Array{{\!keyword{array}}}%
\def\At{{\!keyword{at}}}%
\def\Begin{{\!keyword{begin}}}%
\def\Body{{\!keyword{body}}}%
\def\Case{{\!keyword{case}}}%
\def\Constant{{\!keyword{constant}}}%
\def\Declare{{\!keyword{declare}}}%
\def\Delay{{\!keyword{delay}}}%
\def\Delta{{\!keyword{delta}}}%
\def\Digits{{\!keyword{digits}}}%
\def\Do{{\!keyword{do}}}%
\def\Else{{\!keyword{else}}}%
\def\Elsif{{\!keyword{elsif}}}%
\def\End{{\!keyword{end}}}%
\def\Entry{{\!keyword{entry}}}%
\def\Exception{{\!keyword{exception}}}%
\def\Exit{{\!keyword{exit}}}%
\def\For{{\!keyword{for}}}%
\def\Function{{\!keyword{function}}}%
\def\Generic{{\!keyword{generic}}}%
\def\Goto{{\!keyword{goto}}}%
\def\If{{\!keyword{if}}}%
\def\In{{\!keyword{in}}}%
\def\Is{{\!keyword{is}}}%
\def\Limited{{\!keyword{limited}}}%
\def\Loop{{\!keyword{loop}}}%
\def\Mod{{\!keyword{mod}}}%
\def\New{{\!keyword{new}}}%
\def\Not{{\!keyword{not}}}%
\def\Null{{\!keyword{null}}}%
\def\Of{{\!keyword{of}}}%
\def\Or{{\!keyword{or}}}%
\def\Others{{\!keyword{others}}}%
\def\Out{{\!keyword{out}}}%
\def\Package{{\!keyword{package}}}%
\def\Pragma{{\!keyword{pragma}}}%
\def\Private{{\!keyword{private}}}%
\def\Procedure{{\!keyword{procedure}}}%
\def\Raise{{\!keyword{raise}}}%
\def\Range{{\!keyword{range}}}%
\def\Record{{\!keyword{record}}}%
\def\Rem{{\!keyword{rem}}}%
\def\Renames{{\!keyword{renames}}}%
\def\Return{{\!keyword{return}}}%
\def\Reverse{{\!keyword{reverse}}}%
\def\Select{{\!keyword{select}}}%
\def\Separate{{\!keyword{separate}}}%
\def\Subtype{{\!keyword{subtype}}}%
\def\Task{{\!keyword{task}}}%
\def\Terminate{{\!keyword{terminate}}}%
\def\Then{{\!keyword{then}}}%
\def\Type{{\!keyword{type}}}%
\def\Use{{\!keyword{use}}}%
\def\When{{\!keyword{when}}}%
\def\While{{\!keyword{while}}}%
\def\With{{\!keyword{with}}}%
\def\Xor{{\!keyword{xor}}}%
%
%begin ANNA
\def\Axiom{{\!keyword{axiom}}}%
\def\Exist{{\!keyword{exist}}}%
\def\Isin{{\!keyword{isin}}}%
\def\To{{\!keyword{to}}}%
\def\Where{{\!keyword{where}}}%
%end ANNA
%
%begin TSL
\def\Accepts{{\!keyword{accepts}}}%
\def\Action{{\!keyword{action}}}%
\def\Activates{{\!keyword{activates}}}%
\def\Any{{\!keyword{any}}}%
\def\Before{{\!keyword{before}}}%
\def\Calls{{\!keyword{calls}}}%
\def\From{{\!keyword{from}}}%
\def\Macro{{\!keyword{macro}}}%
\def\Main{{\!keyword{main}}}%
\def\Milliseconds{{\!keyword{milliseconds}}}%
\def\Opens{{\!keyword{opens}}}%
\def\Perform{{\!keyword{perform}}}%
\def\Performs{{\!keyword{performs}}}%
\def\Property{{\!keyword{property}}}%
\def\Releases{{\!keyword{releases}}}%
\def\Self{{\!keyword{self}}}%
\def\Set{{\!keyword{set}}}%
\def\Terminates{{\!keyword{terminates}}}%
\def\Until{{\!keyword{until}}}%
\def\Whenever{{\!keyword{whenever}}}%
\def\Where{{\!keyword{where}}}%
%end TSL
%
% Some more global definitions follow:
%
\def\!lbr{\/$($}%
\def\!rbr{\/$)$}%
\def\!str{\/$*$}%
\def\!pls{\/$+$}%
\def\!min{\/$-$}%
\def\!col{\/$:$}%
\def\!scl{\/$;$}%
\def\!les{\/$<$}%
\def\!gre{\/$>$}%
\def\!bar{\/$|$}%
\def\!equ{\/$=$}%
%
\def\!sla{\/{\sl{/}}}%
\def\!dqt{{\/\raise.2ex\hbox{\tt{"}}}}%
\def\!dots{\/.{\hskip1mm}.}%
\def\!comment{{\apecommentfont\rm--\thinspace--}}%
%
%begin ANNA
\def\!virtualtext{\!comment\thinspace$:$}%
\def\!annotation{\!comment\thinspace$|$}%
%end ANNA
%begin TST
\def\!tsltext{\!comment\thinspace$+$}%
%end TSL
%
\def\!hinge{\vfil\penalty5000\vfilneg}%
\def\!space{\hskip\apehspace}%
\def\!underscore{\underbar{\!space}}%
%
% Now follow the global definitions for the tabbing commands.  First a set of
% dimen, count and box registers are allocated.  The number of dimen registers
% limit the total number of tabs permitted.
%
\newdimen\!apetabi%
\newdimen\!apetabii%
\newdimen\!apetabiii%
\newdimen\!apetabiv%
\newdimen\!apetabv%
\newdimen\!apetabvi%
\newdimen\!apetabvii%
\newdimen\!apetabviii%
\newdimen\!apetabix%
\newdimen\!apetabx%
\newdimen\!apetabxi%
\newdimen\!apetabxii%
\newdimen\!apetabxiii%
\newdimen\!apetabxiv%
\newdimen\!apetabxv%
\newdimen\!apetabxvi%
\newdimen\!apetabxvii%
\newdimen\!apetabxviii%
\newdimen\!apetabxix%
\newdimen\!apetabxx%
\newcount\!apetotaltabs%
\newcount\!apetab%
\newbox\!apetabbox%
\newbox\!apelinebox%
%
% Dimen register i stores the distance from the tab stop (i-1) to the tab stop
% i.  \!apetotaltabs maintains the total number of tabs currently set.
% \!apetab maintains the tab stop that will be reached if another '&' is
% encountered.  The box registers are explained below.
%
% Between the beginning of lines, tab stops and the end of lines, text is
% formatted into the box \!apetabbox and padded on the right with the glue
% \hss.  The macro \!apebbox is what needs to be done at the beginning of each
% of these boxes.
%
\def\!apebbox{%
	\ifnum\!apetab>\!apetotaltabs%
		\setbox\!apetabbox=\hbox%
	\else%
		\setbox\!apetabbox=\hbox to \csname !apetab%
		\romannumeral\!apetab\endcsname%
	\fi\bgroup{}%
}%
%
% The boxes mentioned above (that are stored into \!apetabbox) are put together
% into another \hbox called \!apelinebox.  This box is output once a full line
% has been read from input.  The macro \!apebline does what is needed at the
% beginning of each input line, while the macro \!apeeline does what is needed
% at the end of each input line.
%
\def\!apebline{%
	\noindent\global\!apetab=1{}\setbox\!apelinebox=\hbox\bgroup%
	\hskip\apelmargin\!apebbox%
}%
%
\def\!apeeline{\hss\egroup\box\!apetabbox\egroup\box\!apelinebox}%
%
% The macro \!apekill is similar to \!apeeline, except that it does not output
% the contents of \!apelinebox.  In addition, this macro also performs a
% \!apebline, thus getting ready for the next line of input.
%
\def\!apekill{\hss\egroup\box\!apetabbox\egroup\!apebline}%
%
% The macro \!apetabskip is expanded when an '&' is encountered in the input
% file.  It ends the current \!apetabbox, and if a new tab stop needs to be
% set, it increments the counters appropriately and sets the appropriate dimen
% register to the width of \!apetabbox.  Finally, \!apebbox is invoked to start
% off a new \!apetabbox.
%
\def\!apetabskip{%
	\hss\egroup%
	\ifnum\!apetab>\!apetotaltabs%
		\global\advance\!apetotaltabs by 1{}\global\csname !apetab%
		\romannumeral\!apetotaltabs\endcsname=\wd\!apetabbox%
	\fi%
	\box\!apetabbox\global\advance\!apetab by 1{}\!apebbox{}%
}%
%
\def\!apecr{\strut\par\!break\vskip\apevspace}%
%
\def\!par{\!apeeline\!apecr\!apebline}%
%
% The following global definitions are for formatting Ada comments.  The macros
% \!cma and \!cmb are used in the definition of the \cm macro later.  The
% comment text is split at all \bhinge's and \ehinge's.  Each portion of the
% comment is then put into a \vbox separately and output one after the other.
% Actually all but the last line of each \vbox is output.  The last line is
% included at the beginning of the next \vbox.  At the end of it all, there
% will be one more line to output.  \!cmb explicitly outputs this line, and
% moves back to the beginning of this line.  The box registers below are used
% to store the boxes created during this process.  Dimen register \!cmtpos
% contains the distance of the comment from the left margin while \!cmtwd
% contains the width of the comment.
%
\newif\ifnonvoid%
\newbox\!cmti%
\newbox\!cmtii%
\newbox\!cmtiii%
\newbox\!cmtiv%
\newbox\!cmtv%
\newbox\!cmtvi%
\newdimen\!cmtpos%
\newdimen\!cmtwd%
%
% \!cmtout is the output routine.  It assumes that the \hboxes to be output are
% enclosed within a \vbox in \!cmti.  It consists mainly of two loops.  The
% first loop reverses the order of the \hboxes in \!cmti and puts this into a
% \vbox in \!cmtv.  The second loop pulls out the \hboxes from \!cmtv and
% outputs them.
%
\def\!cmtout{%
	\setbox\!cmtii=\vbox{\unvbox\!cmti\global\setbox\!cmtiii=%
	\lastbox\unskip\unpenalty}%
	\nonvoidtrue%
	\ifvoid\!cmtiii%
		\nonvoidfalse%
	\fi%
	\ifnonvoid%
		\setbox\!cmti=\box\!cmtii%
		\setbox\!cmtv=\vbox{\box\!cmtiii}%
		\nonvoidtrue%
		\loop%
			\setbox\!cmtii=\vbox{\unvbox\!cmti\global\setbox%
			\!cmtiii=\lastbox\unskip\unpenalty}%
			\ifvoid\!cmtiii%
				\nonvoidfalse%
			\fi%
		\ifnonvoid%
			\setbox\!cmti=\box\!cmtii%
			\setbox\!cmtiv=\vbox{\unvbox\!cmtv\box\!cmtiii}%
			\setbox\!cmtv=\box\!cmtiv%
		\repeat%
		\nonvoidtrue%
		\loop%
			\setbox\!cmtii=\vbox{\unvbox\!cmtv\global\setbox%
			\!cmtiii=\lastbox}%
			\ifvoid\!cmtiii%
				\nonvoidfalse%
			\fi%
		\ifnonvoid%
			\setbox\!cmtv=\box\!cmtii%
			\noindent\hskip\!cmtpos\!comment{}\!space%
			\box\!cmtiii{}\!apecr%
		\repeat%
	\fi%
}%
%
% The following two macros \!cmtbhinge and \!cmtehinge end the current comment
% box being created.  They then pull out the last line from this box and ship
% the rest of the box to \!cmtout.  The value of \!break is then modified to
% ensure that the correct penalty value is inserted at the end of the next
% line.  They then start off a new comment box after inserting the last line
% of the previous box and a space character at the beginning.
%
\def\!cmtbhinge{%
	\egroup%
	\setbox\!cmtii=\vbox{\unvbox\!cmti\global\setbox\!cmtiii=%
	\lastbox\unskip\unpenalty}%
        \setbox\!cmtvi=\hbox{\unhbox\!cmtiii\unskip\unskip\unpenalty}%
	\setbox\!cmti=\box\!cmtii\!cmtout%
	\global\def\!break{\!hinge}%
	\setbox\!cmti=\vbox\bgroup\hsize=\!cmtwd%
	\noindent\apecommentfont{}\unhbox\!cmtvi{} %
}%
%
\def\!cmtehinge{%
	\egroup%
	\setbox\!cmtii=\vbox{\unvbox\!cmti\global\setbox\!cmtiii=%
	\lastbox\unskip\unpenalty}%
        \setbox\!cmtvi=\hbox{\unhbox\!cmtiii\unskip\unskip\unpenalty}%
	\setbox\!cmti=\box\!cmtii\!cmtout%
	\global\def\!break{\nobreak}%
	\setbox\!cmti=\vbox\bgroup\hsize=\!cmtwd%
	\noindent\apecommentfont{}\unhbox\!cmtvi{} %
}%
%
% \!cma begins the comment by finishing off the boxes being created and then
% outputting them.  It also measures the width of the box output to determine
% the value of \!cmtpos.
%
\def\!cma{%
	\egroup\setbox\!cmti=\hbox{\unhbox\!apetabbox}%
	\box\!cmti\egroup%
	\!cmtpos=\wd\!apelinebox%
	\hbox to 0pt{\box\!apelinebox\hss}%
}%
%
% \!cmb takes over from \cm.  It starts off the first comment box and finishes
% off the last comment box.  If there is only one comment box (no \bhinge or
% \ehinge in between), then it starts and finishes this one box.  It then pulls
% out the last line of the last box and ships the rest of the box to \!cmtout.
% It then outputs the last comment line and moves to the beginning of the line
% in which the last comment line was output.
%
\def\!cmb#1#2{%
	\!cmtwd=#1%
	\setbox\!cmti=\vbox\bgroup\hsize=\!cmtwd\noindent%
	\apecommentfont{}#2\egroup%
	\setbox\!cmtii=\vbox{\unvbox\!cmti\global\setbox\!cmtvi=%
	\lastbox\unskip\unpenalty}%
	\setbox\!cmti=\box\!cmtii\!cmtout%
	\noindent\hbox to 0pt{\hskip\!cmtpos\!comment{}\!space\box\!cmtvi\hss}%
	\endgroup%
	\!apebline%
}%
%
% The following global definition of \!ap is used in the definition of the \ap
% macro later.  As in the case of \!cmb and \cm, there is an \endgroup in \!ap
% whose corresponding \begingroup is in \ap.  In this case, there is also a
% corresponding \apebegin in \ap.
%
\def\!ap#1{#1\apeend\endgroup{}}%
%
% We cannot have the sequence "\let=\!equ" within the body of the ape macro
% since the "=" will not be scanned with the correct category code.  Hence, the
% macro \!defequ is defined in an environment where "=" has the correct
% category code, and then this macro is used within the body of the ape macro.
% \!defequ is now defined as a global macro.
%
{%
\catcode`\==\active%
\gdef\!defequ{\let=\!equ}%
}%
%
\catcode`\!=12%
\catcode`\^^I=10%
%
% END OF GLOBAL DEFINITIONS.
%
% NOW THE MACRO DEFINITIONS:
%
% The macro has to be defined in an environment with the category codes set
% correctly.  This environment is first set up below, and then within this
% environment, the macros are defined.
%
{%
%
% Firstly, "outer" macros cannot occur within any macro expansions.  The only
% such macro that occurs in the macros below is \+.  Hence this is redefined to
% its usual value.  The effect of this redefinition just changes the status of
% \+ to now be a non-"outer" macro.
%
\def\+{\tabalign}%
%
% Necessary changes to category codes are made right now since category codes
% are used while scanning and the macro is scanned at definition time, and not
% at macro expansion time.
%
\catcode`\(=\active%
\catcode`\)=\active%
\catcode`\*=\active%
\catcode`\+=\active%
\catcode`\-=\active%
\catcode`\:=\active%
\catcode`\;=\active%
\catcode`\<=\active%
\catcode`\>=\active%
\catcode`\|=\active%
\catcode`\/=\active%
\catcode`\"=\active%
\catcode`\^^M=\active%
\catcode`\ =\active%
\catcode`\_=\active%
\catcode`\!=11%
\catcode`\&=\active%
%
\gdef\apebegin{\begingroup\global\def\!break{\nobreak}%
%
% First the category codes of the characters to be redefined are made active.
%
\catcode`\(=\active%
\catcode`\)=\active%
\catcode`\*=\active%
\catcode`\+=\active%
\catcode`\-=\active%
\catcode`\:=\active%
\catcode`\;=\active%
\catcode`\<=\active%
\catcode`\>=\active%
\catcode`\|=\active%
\catcode`\/=\active%
\catcode`\"=\active%
\catcode`\^^M=\active%
\catcode`\ =\active%
\catcode`\_=\active%
\catcode`\!=11%
\catcode`\&=\active%
%
% Now each of these characters is given its definition.
%
\let(=\!lbr%
\let)=\!rbr%
\let*=\!str%
\let+=\!pls%
\let-=\!min%
\let:=\!col%
\let;=\!scl%
\let<=\!les%
\let>=\!gre%
\let|=\!bar%
\let/=\!sla%
\let"=\!dqt%
\let^^M=\!par%
\let =\!space%
\let_=\!underscore%
\catcode`\^^A=8\def\_{^^A}%
%
% The above two lines interchange the meanings of _ and \_.  To do this, a new
% subscript character ^A is defined, and then \_ is defined as a macro to
% expand to ^A.
%
\let&=\!apetabskip%
%
% Now follows the remaining macro declarations needed to complete the \ape
% environment.
%
\def\.{\!dots}%
\def\,{\thinspace{}}%
\def\-{\!comment}%
%
%begin ANNA
\def\:{\!virtualtext}%
\def\|{\!annotation}%
%end ANNA
%begin TSL
\def\T{\!tsltext}%
%end TSL
%
\def\bhinge{\global\def\!break{\!hinge}}%
\def\ehinge{\global\def\!break{\nobreak}}%
\def\\^^M{\bhinge^^M\ehinge}%
\def\actabs{\global\!apetotaltabs=0\global\!apetab=1{}}%
\def\killtabs{\actabs}%
\actabs%
\def\kill^^M{\!apekill}%
\def\killline{\kill}%
\def\!keyword{\apekeywordfont}%
%
% Following is the \cm macro definition.  This macro eventually lets the macro
% \!cmb take over so that the text following is read in with the correct
% category codes.  The redefinition of \+ below is for the same reason as
% before: to convert it from an outer to a non-outer macro.
%
\def\+{\tabalign}%
%
\def\cm{\!cma\begingroup%
%
% The category codes are temporarily changed back to their original values.
%
\catcode`\(=12%
\catcode`\)=12%
\catcode`\*=12%
\catcode`\+=12%
\catcode`\-=12%
\catcode`\:=12%
\catcode`\;=12%
\catcode`\<=12%
\catcode`\>=12%
\catcode`\|=12%
\catcode`\/=12%
\catcode`\"=12%
\catcode`\^^M=5%
\catcode`\ =10%
\catcode`\!=12%
%
\def\bhinge{\!cmtbhinge}%
\def\ehinge{\!cmtehinge}%
%
\!cmb}%
%
% Now = is redefined.  Had this been done earlier, then it would have affected
% the previous definitions, since many of them contain =.
%
\catcode`\==\active\!defequ%
%
\apebodyfont\!apebline%
%
}%
%
% End of definition of \apebegin
%
\gdef\apeend{\!apeeline\endgroup}%
%
\gdef\ap{\begingroup%
\def\apekeywordfont{\apkeywordfont}%
\def\apecommentfont{\apcommentfont}%
\def\apebodyfont{\apbodyfont}%
\def\apehspace{\aphspace}%
\def\apelmargin{0pt}%
\apebegin\!ap}%
%
% The reason for letting \!ap take over from \ap at this point is to make TeX
% scan the argument with the correct category codes.
%
}%
% This ends the environment in which the macros are defined.
%
